<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2021-01-04 Mon 11:24 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Accelerated Introduction to Computer Science</title>
<meta name="generator" content="Org mode">
<meta name="author" content="jbh">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
   body {
    background-color: #ededed;
    margin: auto;
    padding: 0.5rem;
    max-width: 80ch; 
  }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<header>
<h1 class="title">Accelerated Introduction to Computer Science</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orge06991f">Intro</a></li>
<li><a href="#orga072af7">Start here</a>
<ul>
<li><a href="#orgb8b6172">Materials needed to complete this</a></li>
</ul>
</li>
<li><a href="#org372ab4e">Lecture 1 CS019 Pyret Demo</a>
<ul>
<li><a href="#orgcfb1be8">Reading PAPL</a></li>
<li><a href="#orgbfe378e">Reading chapter 4</a></li>
<li><a href="#orga42d8c1">Reading chapter 5</a></li>
</ul>
</li>
<li><a href="#orgcfd1d5d">Lecture 2 CS019 Rainfall Problem</a>
<ul>
<li><a href="#orgebd18d9">How to write examples</a></li>
</ul>
</li>
<li><a href="#orgd06907a">Optional reading PAPL</a>
<ul>
<li><a href="#orgf33f6b7">Chapter 6</a></li>
<li><a href="#orgd9548b8">Chapter 7 &amp; 8</a></li>
<li><a href="#org5eda8b5">Recitation: lambdas</a></li>
<li><a href="#org36377b1">Recitation: lists and recursion</a></li>
<li><a href="#org0cdb86e">Reading chapter 9 &amp; 10</a></li>
</ul>
</li>
<li><a href="#orgbfe0790">Lecture 3 CS019 Insertion Sort</a>
<ul>
<li><a href="#orgb75fd1b">Lab: Higher-Order Functions</a></li>
</ul>
</li>
<li><a href="#org44f40f7">Requirements Analysis</a></li>
<li><a href="#org9ed918e">Assignment 1: DocDiff</a>
<ul>
<li><a href="#orgcc35b5e">A study about us, beginner students</a></li>
<li><a href="#org4a96d7d">DocDiff</a></li>
</ul>
</li>
<li><a href="#orgd967eff">Lecture 4 CS019 Big-O</a>
<ul>
<li><a href="#org6a92e32">Reading Chapter 17</a></li>
</ul>
</li>
<li><a href="#org203d715">Lecture 5 CS019 Insertion Sort Reccurrence</a>
<ul>
<li><a href="#org70b324a">More Recurrences</a></li>
<li><a href="#org8d076ce">Return to 17.10 Recurrences</a></li>
<li><a href="#org5489972">Lab: Big-O 1</a></li>
</ul>
</li>
<li><a href="#org7e7c866">Lecture 6 CS019 Quicksort</a></li>
<li><a href="#org7b8ce5b">Assignment 2: Nile</a></li>
<li><a href="#org6d0d971">Assignment 3: Sortacle</a>
<ul>
<li><a href="#org17f5960">Check your work against the official solution</a></li>
<li><a href="#org65b07cc">Logic for Systems</a></li>
</ul>
</li>
<li><a href="#org0320dbe">Assignment 4: Data Scripting</a></li>
<li><a href="#org9fc5732">Lecture 7 CS019 Trees</a>
<ul>
<li><a href="#org467dc24">Reading Chapter 11</a></li>
<li><a href="#org47b23bf">Reading Chapter 12</a></li>
<li><a href="#org5ad3484">Reading Chapter 13</a></li>
</ul>
</li>
<li><a href="#orgb5d4773">Lecture 8 CS019 Sets</a>
<ul>
<li><a href="#org001a6c8">Reading Chapter 18</a></li>
<li><a href="#orgd933ebc">Reading Chapter 15</a></li>
</ul>
</li>
<li><a href="#orgb47b061">Assignment 5: Oracle</a>
<ul>
<li><a href="#orgee8c185">Check your solution</a></li>
<li><a href="#orgdb8347e">Future assignments auditing</a></li>
</ul>
</li>
<li><a href="#org14d6e61">Lecture 9 CS019 Logarithmic Growth</a></li>
<li><a href="#org5e834d3">Lecture 10 CS019 Balanced Binary Search Trees</a>
<ul>
<li><a href="#org1e0b76d">Reading Chapter 17.2</a></li>
<li><a href="#orga1fc806">Lab: Tree traversal</a></li>
</ul>
</li>
<li><a href="#org7a7290c">Assignment 6: Filesystem</a></li>
<li><a href="#orgf3ab9e0">Lecture 11 CS019 Streams</a>
<ul>
<li><a href="#org8a1279c">Reading Chapter 16</a></li>
<li><a href="#orgdabc4cb">Lab: Streams</a></li>
</ul>
</li>
<li><a href="#orgee228f9">Lecture 12 CS019 Model View Controllers</a></li>
<li><a href="#orgd636eb1">Lecture 13 CS019 Differential Systems</a></li>
<li><a href="#org889b37b">Lecture 14 CS019 Aliasing</a></li>
<li><a href="#org9382269">Lecture 15 CS019 Monads, Sequential Computation</a></li>
<li><a href="#org4075243">Lectures Memory mutation</a>
<ul>
<li><a href="#orgc5e55eb">Lecture 24 Memory refs</a></li>
<li><a href="#org4cb18c0">Lecture 25 Closures</a></li>
<li><a href="#org9a6561d">Reading Chapter 22</a></li>
<li><a href="#org5611ed5"><span class="todo TODO">TODO</span> Lecture 26 The Halting problem</a></li>
</ul>
</li>
<li><a href="#org9c2e2e1">The rest of the cs19 lectures</a></li>
</ul>
</div>
</nav>

<div id="outline-container-orge06991f" class="outline-2">
<h2 id="orge06991f">Intro</h2>
<div class="outline-text-2" id="text-orge06991f">
<p>
This is part IA of the <a href="https://learnaifromscratch.github.io">AI Tripos</a> to learn <a href="http://bactra.org/reviews/nature-of-computation.html">computation</a> from scratch. If you only have a phone you can complete this: we use a <a href="https://code.pyret.org/">web interpreter</a> and <a href="https://code.fandom.com/wiki/Online_judge">online judges</a> to run and test our code so any phone editor that can save in plain text will do. We will learn the foundations of every programming language, how to design algorithms and everything about their <a href="https://www.youtube.com/playlist?list=PLm3J0oaFux3ZYpFLwwrlv_EHH9wtH6pnX">complexity</a> by doing small daily challenges whenever time allows. 
</p>
</div>
</div>

<div id="outline-container-orga072af7" class="outline-2">
<h2 id="orga072af7">Start here</h2>
<div class="outline-text-2" id="text-orga072af7">
<p>
We begin with Brown University's CS019 <i>Accelerated Introduction to Computer Science</i>. You don't have to do it all linearly we can take it up to a certain point then use the rest of the course as our research material for doing competitive programming problem sets. Look around the instructor's <a href="https://cs.brown.edu/~sk/">page</a> like his manifesto on the current state of compsci education.  
</p>
</div>

<div id="outline-container-orgb8b6172" class="outline-3">
<h3 id="orgb8b6172">Materials needed to complete this</h3>
<div class="outline-text-3" id="text-orgb8b6172">
<p>
As stated in the intro it's possible to complete this course with just a phone or a tablet, the interpreter you use is online and even has a static type checker
</p>
<ul class="org-ul">
<li>the <a href="https://papl.cs.brown.edu/2020/">book</a> <i>Programming and Programming Languages</i> (use the most latest version, which is 2020)</li>
<li>lectures are on <a href="https://www.youtube.com/playlist?list=PLl0tHXI7SBjncgRrhL4DPEwDgUjUtk2_C">YouTube</a>
<ul class="org-ul">
<li>the lectures cover extra material not in the book</li>
</ul></li>
<li>a web browser to use the Pyret online <a href="https://www.pyret.org/set-sail/">interpreter</a> (CPO)</li>
<li>the 2018 copy of the <a href="https://cs.brown.edu/courses/cs019/2018/assignments.html">assignments</a> since we are watching the 2018 lectures</li>
<li>the labs at the bottom of this <a href="https://cs.brown.edu/courses/cs019/2016/assignments.html">page</a> (Big-O, Higher-Order Functions, Streams etc).</li>
</ul>
</div>

<div id="outline-container-orgd79f7ef" class="outline-4">
<h4 id="orgd79f7ef">Torrent archive</h4>
<div class="outline-text-4" id="text-orgd79f7ef">
<p>
I made a torrent w/the lectures and labs:
</p>
<pre class="example">
CS019 2018 Lectures, labs
magnet:?xt=urn:btih:5db2ed40c8952ea69a06c4ab940d168bc2798a49&amp;dn=cs019
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org372ab4e" class="outline-2">
<h2 id="org372ab4e">Lecture 1 CS019 Pyret Demo</h2>
<div class="outline-text-2" id="text-org372ab4e">
<p>
We're starting with the lecture titled <a href="https://www.youtube.com/playlist?list=PLl0tHXI7SBjncgRrhL4DPEwDgUjUtk2_C">Wed 9-5-18</a>. Go to code.pyret.org (referred to as CPO) and click <i>open editor</i> as you follow along the lecture. The book will cover everything he's doing like what a list is, what a function is, this is just a demonstration of the online interpreter. You can run Pyret <a href="https://www.pyret.org/set-sail/">offline</a> too. 
</p>

<p>
Notice he shuts down a lot of out of scope questions to not derail the lecture. @34:20 is the private app Exemplar which we don't have access to. The professor's university page has a paper on Exemplar detailing how many tests the students typically write which is 30+. 
</p>

<p>
So how can we figure out the student given test cases for the median program? By looking up what a <a href="https://en.wikipedia.org/wiki/Median">median</a> is and the procedure to find it. Reading that article we see that the median is a value that seperates a finite list of numbers, that can be found by arranging them from the smallest to the greatest. If there is an odd number of entries, the middle number that splits the list into two even parts is picked. Otherwise it is defined to be the mean of the two middle values which means add them both and divide by 2, the idea being getting as close as possible to evenly splitting the data. That's why the test for [list: 1, 3, 2] is 2 because your program would reorder the list to be [list: 1, 2, 3] and choose 2 as the median. The Fermi problems he talks about must be released on Piazza which requires campus logins, <a href="https://piazza.com/class">https://piazza.com/class</a> is a kind of wiki/msg forum for courses that encourages anonymous postings so students don't feel embarassed to ask questions. A lot of universities now solely distribute their course materials through it meaning the public doesn't have access anymore. You can find these yourself online anyway by searching for Fermi problems. 
</p>

<p>
At the end he mentions the design recipe, as a way to save TAs time, explaining if you show up to office hours for help they will go about writing a template with the student, going through all the various stages and not just giving them an answer. He notes it is totally optional to use the design recipe, but it will help you with the hard assignments and if you're going to office hours with a lot of questions clearly your methods aren't working so why not try their method. If you read the <a href="https://cs.brown.edu/~sk/Publications/Papers/Published/rkf-student-ta-hours/">paper</a> <i>What Help Do Students Seek in TA Office Hours</i> the design recipe is talked about, templates are covered in the third lecture as a tool to extract 'code for free' from your data.  
</p>
</div>


<div id="outline-container-orgcfb1be8" class="outline-3">
<h3 id="orgcfb1be8">Reading PAPL</h3>
<div class="outline-text-3" id="text-orgcfb1be8">
<p>
Let's work through the <a href="https://papl.cs.brown.edu/2020/">book</a> <i>Programming and Programming Languages</i>, I'm using whatever the latest version is (as of this writing, 2020). 
</p>

<p>
Chapter 3 <i>Getting Started</i> read while you have CPO open (<a href="https://code.pyret.org">https://code.pyret.org</a>). The examples with many "&gt;" in front of them indicates enter this into the <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a>, on the right hand side of the pyret code editor like he did in the lecture pressing enter to eval. It's running a read-eval-print-loop (repl) which means exactly what you think it means. It reads input, evaluates it, prints it to the console and then loops back waiting to read input again. You can increase the font size if you click the lambda skull logo on the top left side.
</p>
</div>
</div>


<div id="outline-container-orgbfe378e" class="outline-3">
<h3 id="orgbfe378e">Reading chapter 4</h3>
<div class="outline-text-3" id="text-orgbfe378e">
<p>
You spent all of the last chapter entering commands into the REPL on the right hand side of the pyret online editor, now you'll use the left hand side to write functions and run them by either pressing Ctrl-Enter or the <i>Run</i> button. If you make a mistake like accidentally deleting all your code Ctrl-z will undo on most browsers I tested it on. This is a good chapter telling you exactly what is evaluated and how when you click <i>run</i>. Note 4.3 in the 2020 papl version seems to be an error, width = 30 should create a new directory entry for width and associate it with value 30 (not 'size'). 
</p>
</div>
</div>

<div id="outline-container-orga42d8c1" class="outline-3">
<h3 id="orga42d8c1">Reading chapter 5</h3>
<div class="outline-text-3" id="text-orga42d8c1">
<ul class="org-ul">
<li>There is an optional recorded recitation for this chapter <a href="https://youtu.be/kR1DvZ17mkc">here</a></li>
</ul>

<p>
This chapter tells you exactly how functions are defined and run by Pyret. He writes the examples like how the code in the body of the function would look like, such as "is 5 * 0.25" this is to help you write the function itself by first working through the examples. Now that you've worked through this chapter, read some of 4.1 <i>Functions as Templates</i> from this <a href="http://www.cs.cmu.edu/~rwh/isml/book.pdf">pdf</a>. He describes functions as containing 'holes that fit a pattern' you may find illuminating and parameters as placeholders. The math example at the end he's trying to show the concept of a variable is similar to substitution in highschool math, but different from the idea of an 'assignable' which is mutated memory we will learn later. 
</p>
</div>
</div>
</div>


<div id="outline-container-orgcfd1d5d" class="outline-2">
<h2 id="orgcfd1d5d">Lecture 2 CS019 Rainfall Problem</h2>
<div class="outline-text-2" id="text-orgcfd1d5d">
<p>
Watch the Mon9/10/18 second lecture. Interesting lecture about the rainfall problem and the benefits of writing a lot of examples in order to understand badly defined problems. Data science/machine learning is brought up, as examples of dirty data. Higher-order functions are talked about, like filter and map which are in the pyret documentation. 
</p>
</div>

<div id="outline-container-orgebd18d9" class="outline-3">
<h3 id="orgebd18d9">How to write examples</h3>
<div class="outline-text-3" id="text-orgebd18d9">
<p>
This <a href="https://youtu.be/cTQI4iN1VDg">recitation video</a> goes through some drill questions from CS0111 and talks about creating good examples.
</p>
</div>
</div>
</div>

<div id="outline-container-orgd06907a" class="outline-2">
<h2 id="orgd06907a">Optional reading PAPL</h2>
<div class="outline-text-2" id="text-orgd06907a">
<p>
Everything here is optional, you can do it was you go through the lectures and come across things you don't understand.
</p>
</div>

<div id="outline-container-orgf33f6b7" class="outline-3">
<h3 id="orgf33f6b7">Chapter 6</h3>
<div class="outline-text-3" id="text-orgf33f6b7">
<p>
Conditional expressions and exactly how Pyret evaluates if-branches is defined here.
</p>
</div>
</div>

<div id="outline-container-orgd9548b8" class="outline-3">
<h3 id="orgd9548b8">Chapter 7 &amp; 8</h3>
<div class="outline-text-3" id="text-orgd9548b8">
<ul class="org-ul">
<li>There is a recorded recitation for these chapters <a href="https://youtu.be/3my9aovhOO8">here</a></li>
</ul>

<p>
Tabular data, and what normalizing data means. Remember the rainfall lecture. In the previous versions of PAPL, he noted why they composed these table row operations to be independent of each other so combining them in complex expressions is possible just like <a href="https://youtu.be/6VCHuLqfmV8">SQL</a> or Excel spreadsheets that every trader <a href="https://news.ycombinator.com/item?id=15819016">still uses</a>.  
</p>
</div>
</div>

<div id="outline-container-org5eda8b5" class="outline-3">
<h3 id="org5eda8b5">Recitation: lambdas</h3>
<div class="outline-text-3" id="text-org5eda8b5">
<p>
This <a href="https://youtu.be/vxXFDS95nB4">recorded</a> recitation explains anonymous functions using table row operations as examples.
</p>
</div>
</div>

<div id="outline-container-org36377b1" class="outline-3">
<h3 id="org36377b1">Recitation: lists and recursion</h3>
<div class="outline-text-3" id="text-org36377b1">
<p>
A <a href="https://youtu.be/XEOLa6J2_F0">tutorial</a> on lists, case syntax and recursion helpful when reading chapter 9 and 10. For a list, imagine you are building up a structure one link at a time: link(1, link(2, link(3, &#x2026; and now you want to take apart that structure, so you use recursion to disassemble the structure you built back to the base case. PAPL has a <a href="https://papl.cs.brown.edu/2020/Recursive_Data.html">chapter</a> on this you can skip ahead and read now to see what a template for recursion on lists looks like:
</p>

<pre class="example">
# This is the design recipe for recursive data using type NumList
# Change nl-link to link(first, rest) for regular lists
#|
fun num-list-fun(nl :: NumList) -&gt; ???:
  cases (NumList) nl:
    | nl-empty =&gt; ...
    | nl-link(first, rest) =&gt;
      ... first ...
      ... num-list-fun(rest) ...
  end
end
|#
</pre>

<p>
This template which will work for any assignment in the book, and has you considering 4 things: What type should the function produce? What to do with the empty case, and what to do with the first part of the list, and the rest which is already filled in for you with a recursive call on rest. 
</p>
</div>
</div>

<div id="outline-container-org0cdb86e" class="outline-3">
<h3 id="org0cdb86e">Reading chapter 9 &amp; 10</h3>
<div class="outline-text-3" id="text-org0cdb86e">
<p>
If during an assignment you get stuck come back to this chapter and you will certainly find what you're looking for. I highly recommend doing all the exercises here and understanding everything in fact I would re-read these chapters until you can effortlessly do all the examples and understand exactly how they work, then you're at a point where the rest of the lectures will make sense without having to stop and figure out all steps. There's a silly story about Gordon Ramsay as a junior chef practicing how to make lobster ravioli with a small frozen potato and pasta over 90x after his shift until the restaurant he was at would let him try it on real lobster. He also had to practice slicing a mackerel a few hundred times until they would let him near the more expensive fish. This is what we are doing, practice.  
</p>
</div>

<div id="outline-container-org2b652fd" class="outline-4">
<h4 id="org2b652fd">10.1 Making Lists and Taking Them Apart</h4>
<div class="outline-text-4" id="text-org2b652fd">
<p>
10.1 type all those examples in the REPL to see what they do, like manually linking a list together with the contructor link(link(empty)) which allows you append things on to lists without using a built-in like .append() or the "+" operator. The book walks through each exercise in 10.2 in the rest of the chapter by constructing examples of the behavior of the function. 
</p>
</div>
</div>

<div id="outline-container-org0630038" class="outline-4">
<h4 id="org0630038">10.3 Structural Problems w/Scalar Answers</h4>
<div class="outline-text-4" id="text-org0630038">
<p>
Here we are being taught how to write examples which help us later write the program for my-len() and my-sum(). 10.3.3. there's some errata here, the <a href="https://www.pyret.org/docs/latest/Expressions.html#(part._s~3acases-expr)">case expression</a> you are matching the variants of the list <a href="https://www.pyret.org/docs/latest/lists.html#(part._.The_.List_.Datatype)">datatype</a> with empty/link. 
</p>
</div>
</div>

<div id="outline-container-org9c6c1e5" class="outline-4">
<h4 id="org9c6c1e5">10.4 Structural Problems w/List Answers</h4>
<div class="outline-text-4" id="text-org9c6c1e5">
<p>
There's an exercise to add examples for lists that end with positive numbers, and lists with [link: 0], try it yourself. Reminder that the recursive template can be used for all of these exercises:
</p>

<pre class="example">
#|
fun list-fun(l :: List&lt;???&gt;) -&gt; ???:
  cases (List) l:
    | empty =&gt; ...
    | link(f, r) =&gt;
      ... f ...
      ... list-fun(r) ...
  end
end
|#
</pre>
</div>
</div>



<div id="outline-container-org7560e69" class="outline-4">
<h4 id="org7560e69">10.5 Structural Problems and Sub-Domains</h4>
<div class="outline-text-4" id="text-org7560e69">
<p>
Study my-alternating() and my-max(), note how the empty case was handled. This is how it is evaluated:
</p>

<ul class="org-ul">
<li>input: my-max([list: 1, 2, 3])</li>
<li>num-max(1, num-max(2, num-max(3, 3))) since the rest will be empty case, we return f</li>
<li>num-max(1, num-max(2, 3))</li>
<li>num-max(1, 3)</li>
<li>3</li>
</ul>
</div>
</div>

<div id="outline-container-orgb09b143" class="outline-4">
<h4 id="orgb09b143">10.7 Accumulators</h4>
<div class="outline-text-4" id="text-orgb09b143">
<p>
Read 10.6 how my-avg() was obtained. Here we are shown helper functions inside other functions with the statement: <i>Observe that we do not change my-running-sum itself to take extra arguments. There are multiple reasons for this</i>. One reason is you want simple documentation, user intuitive and bug-free access to my-alternating() just like a typical command shell utility such as change directory (cd) you wouldn't have users init your accumulators with cd(empty, 0, dir-name) you would instead want a simple interface where all internal operations are encapsulated that only takes a single input.   
</p>
</div>
</div>

<div id="outline-container-org6c03fb0" class="outline-4">
<h4 id="org6c03fb0">10.8 Reducing computation</h4>
<div class="outline-text-4" id="text-org6c03fb0">
<p>
In 10.8.4 uniq-rec3: ur = uniq-rec(r) meaning it called uniq-rec with the rest of the list and now is only checking that returned distinct rest instead of having the first element in uniq-rec3 linearly go through the entire rest. If the rest of the list is a billion entries, many of them dupes, then you saved yourself 1 iteration of a billion checks by slicing off the first element and comparing it to an already distinct rest.  
</p>
</div>
</div>

<div id="outline-container-org014974f" class="outline-4">
<h4 id="org014974f">10.9 Polymorphic Types</h4>
<div class="outline-text-4" id="text-org014974f">
<p>
my-max&lt;T&gt;(l :: List&lt;T&gt;) -&gt; List&lt;T&gt; means the list can be any type &lt;T&gt;, but it's first element enforces what type the rest will be (string, number, boolean..). This will come up lecture repeatedly and eventually we will learn <a href="https://papl.cs.brown.edu/2020/para-poly.html">type variables</a>. 
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgbfe0790" class="outline-2">
<h2 id="orgbfe0790">Lecture 3 CS019 Insertion Sort</h2>
<div class="outline-text-2" id="text-orgbfe0790">
<p>
We're watching Wed9/12/18 lecture on sorting. These videos you can change res to 1920x1080 if you want and zoom if you can't see the writing on the whiteboard. 
</p>

<p>
He walks through exactly what a template is and how to extract data to make a template, and spends the rest of the class writing insertion sort using only what we already know so far. You have to hand step through it a little to understand what insertion sort is doing. Function sort() is calling insert() with insert(f, sort(r)) it isn't calling insert(f, r). 
</p>

<p>
Let's step the evaluation by hand with [list: 0, 1, 3, 2] being input to sort(). The following calls to insert happen:
</p>

<ul class="org-ul">
<li>insert(0,(insert(1,(insert(3,(insert(2, [list: empty])))))))</li>
</ul>

<p>
It's like our example with my-len() with 1 + 1 + etc. Evaluation starts at the deepest inner bracket:
</p>

<ul class="org-ul">
<li>insert(2, [list: empty])
<ul class="org-ul">
<li>is list empty? link(2, link(empty))</li>
<li>return to sort(): [list: 2, empty]</li>
</ul></li>
<li>insert(3, [list: 2, empty])
<ul class="org-ul">
<li>is 3 &lt; 2?</li>
<li>link(2, insert(3, [list: empty]))</li>
<li>return to sort(): [list: 2, 3, empty]</li>
</ul></li>
<li>insert(1, [list: 2, 3, empty])
<ul class="org-ul">
<li>is 1 &lt; 2?</li>
<li>then it must the smallest in the entire list:</li>
<li>link(1, [list: 2, 3, empty])</li>
<li>return to sort(): [list: 1, 2, 3, empty]</li>
</ul></li>
<li>insert(0, [list: 1, 2, 3, empty])
<ul class="org-ul">
<li>is 0 &lt; 1?</li>
<li>link(0, [list: 1, 2, 3, empty])</li>
<li>return to sort(): [list: 0, 1, 2, 3, empty]</li>
</ul></li>
<li>no more delayed computations, sort() is finished</li>
</ul>

<p>
The returns to sort():
</p>

<ul class="org-ul">
<li>insert(0,(insert(1,(insert(3, [list: 2, empty])))))</li>
<li>insert(0,(insert(1, [list: 2, 3, empty])))</li>
<li>insert(0, [list: 1, 2, 3, empty])</li>
</ul>

<p>
Everytime a list is returned, the next call to insert can happen because it is complete with insert(n, list).
</p>
</div>

<div id="outline-container-orgb75fd1b" class="outline-3">
<h3 id="orgb75fd1b">Lab: Higher-Order Functions</h3>
<div class="outline-text-3" id="text-orgb75fd1b">
<p>
Let's do the <a href="https://cs.brown.edu/courses/cs019/2016/hofs-lab.pdf">lab</a> on functions as data, and write our own map, filter and fold. 
</p>

<pre class="example">
fun fun-plus-one(num :: Number, func :: (Number -&gt; Number)) -&gt; Number:
  func(num) + 1
end

&gt;&gt;fun-plus-one(16, num-sqr)
&gt;&gt;5
</pre>

<p>
Try entering various built-ins, or one you wrote yourself, as the second parameter to fun-plus-one.
</p>

<p>
<b>Map</b>
</p>

<p>
We're given test cases and asked to implement f-to-c and goldilocks, and given the formula for f to c temperature unit conversion.
</p>

<pre class="example">
fun f-to-c(f-lst :: List&lt;Number&gt;) -&gt; List&lt;Number&gt;:
  cases (List) f-lst:
    | empty =&gt; empty
    | link(f, r) =&gt; 
      link((f - 32) * (5/9), f-to-c(r))
  end
end

fun goldilocks(f-lst :: List&lt;Number&gt;) -&gt; List&lt;String&gt;:
  cases (List) f-lst:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if f &gt; 90:
        link("too hot", goldilocks(r))
      else if f &lt; 70:
        link("too cold", goldilocks(r))
      else:
        link("just right", goldilocks(r))
      end
  end
end
check:
  f-to-c([list: 131, 77, 68]) is [list: 55, 25, 20]
  goldilocks([list: 131, 77, 68]) is [list: "too hot", "just right", "too cold"]
end
</pre>

<p>
We're asked to rewrite goldilocks using map. The data dumped into a map function is whatever the value is at that list index. In this case we know it's a number since f-lst parameter is :: List&lt;Number&gt;.
</p>

<pre class="example">
fun goldilocks2(f-lst :: List&lt; Number&gt;) -&gt; List&lt;String&gt;:
  f-lst.map({(x): if x &gt; 90: "too hot" else if x &lt; 70: "too cold" else: "just right" end})
end
check:
  goldilocks2([list: 131, 77, 68]) is [list: "too hot", "just right", "too cold"]
end
</pre>

<p>
.map() is a built-in method on a list, where f-lst.map() means we are mapping over f-lst. I used the shorthand bracket syntax for lambdas in the Pyret documentation.
</p>

<p>
We could have also rewritten it like the following example, where a seperate function is used for map instead of writing our own lambda:
</p>

<pre class="example">
fun goldilocks(x :: Number) -&gt; String:
  if x &gt; 90:
    "too hot"
  else if x &lt; 70:
    "too cold"
  else:
    "just right"
  end
end

fun goldilocks2(f-lst :: List&lt; Number&gt;) -&gt; List&lt;String&gt;:
  map(goldilocks, f-lst)
end
check:
  goldilocks2([list: 131, 77, 68]) is [list: "too hot", "just right", "too cold"]
end
</pre>

<p>
Now our task is write our own version of map. I used the documentation examples for map as check tests. Remember map consumes a function and a list, applies the function to each entry in the list returning a new list, try to do this yourself before looking at a solution (your solution may be better). For annotations, I used the <a href="https://www.pyret.org/docs/latest/s_annotations.html#(part._s~3aname-ann)">built-in</a> name annotations but if you read through the documentation you can also import annotations, or create your own datatype. The 'T' annotation is described at the end of chapter on processing lists, the notation &lt;T&gt; says that T is a type variable parameter meaning it can be any type, so if you give map a list of numbers it will be type List&lt;Number&gt;, or a list of strings, it will be List&lt;String&gt; etc. 
</p>

<details>
<pre class="example">
fun my-map&lt;T&gt;(func :: (T -&gt; T), l :: List&lt;T&gt;) -&gt; List&lt;T&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      link(func(f), my-map(func, r))
  end
end
check:
  my-map(num-tostring, [list: 1, 2]) is [list: "1", "2"]
  my-map(lam(x): x + 1 end, [list: 1, 2]) is [list: 2, 3]
end
</pre>
</details>

<p>
<b>Filter</b>
</p>

<p>
First two assignments are straight forward to get you to used to using filter, except you have to use string-to-code-points() instead of any built-in string functions. 
</p>

<details>
<pre class="example">
fun tl-dr(lol :: List&lt;String&gt;, length-thresh :: Number) -&gt; List&lt;String&gt;:
  filter(lam(element): string-to-code-points(element).length() &lt;= length-thresh end, lol)
end
check:
  tl-dr([list: "dkfjdkj", "hi", "dkfjk"], 2) is [list: "hi"]
  tl-dr([list: "corner", "case", ""], 2) is [list: ""]
  tl-dr([list: "a", "b", "c"], 0) is empty
end

fun eliminate-e(words :: List&lt;String&gt;) -&gt; List&lt;String&gt;:
  doc: "I got 101 and 69 from string-to-code-points(e) or (E)"
  filter(lam(element): if string-to-code-points(element).member(101) or
    string-to-code-points(element).member(69): false else: true end end, words)
end
check:
  eliminate-e([list: "e"]) is empty
  eliminate-e([list: "there's", "no", "letter", "e", "here"]) is [list: "no"]
  eliminate-e([list: "hEy", "101e"]) is empty
end
</pre>
</details>

<p>
Lambda parameters can be a single letter: filter(lam(x): x &gt; 1 end) as it's immediately evident what that parameter is and it's scope is limited. Task: implement our own version of filter, which is similar to what we did for map:
</p>

<details>
<pre class="example">
fun my-filter&lt;T&gt;(func :: ( T -&gt; Boolean), l :: List&lt;T&gt;)-&gt; List&lt;T&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if func(f):
        link(f, my-filter(func, r))
      else:
        my-filter(func, r)
      end
  end
end
check:
  fun length-is-one(s :: String) -&gt; Boolean:
    string-length(s) == 1
  end
  my-filter(length-is-one, [list: "ab", "a", "", "c"]) is [list: "a", "c"]
  my-filter(is-link, [list: empty, link(1, empty), empty]) is [list: link(1, empty)]
end
</pre>
</details>

<p>
<b>Fold</b>
</p>

<p>
Try the two tasks: list-product and list-max:
</p>

<details>
<pre class="example">
fun list-product(lon :: List&lt;Number&gt;) -&gt; Number:
  fold(lam(acc, n): acc * n end, 1, lon)
end
check:
  list-product([list: 2, 2, 2]) is 8
  list-product([list: 0, 1, 2]) is 0
  list-product([list: -1, -1]) is 1
end
</pre>

<p>
There's a bug here to fix, try all negative examples
Found by <a href="https://github.com/rand-anon-007">https://github.com/rand-anon-007</a>
</p>
<pre class="example">
fun list-max(lon :: List&lt;Number&gt;) -&gt; Number:
  fold(lam(acc, n): if n &gt; acc: n else: acc end end, 0, lon)
end
check:
  list-max([list: -1, 1, 2]) is 2
  list-max([list: 0, -100, 1]) is 1
  list-max([list: 1/2, 3/4]) is 3/4
end
</pre>

<p>
The problem is the accumulator needs to be initialized with the first value of the list, well actually the problem is I didn't write enough example tests:
</p>

<pre class="example">
fun list-max(lon :: List&lt;Number&gt;) -&gt; Number:
  fold(lam(acc, n): if n &gt; acc: n else: acc end end, lon.get(0), lon)
where:
  list-max([list: -1, 1, 2]) is 2
  list-max([list: 0, -100, 1]) is 1
  list-max([list: 1/2, 3/4]) is 3/4
  list-max([list: -1, -2, -3]) is -1
  list-max([list: 0]) is 0
# list-max(empty) what about this case?
end
</pre>

<p>
Then we come to another problem, what if the list is empty then long.get(0) returns an error:
</p>

<pre class="example">
fun list-max(lon :: List&lt;Number&gt;) -&gt; Number:
  if lon == empty:
    0 # is this correct?
  else:
    fold(lam(acc, n): if n &gt; acc: n else: acc end end, lon.get(0), lon)
  end
where:
  list-max([list: -1, 1, 2]) is 2
  list-max([list: 0, -100, 1]) is 1
  list-max([list: 1/2, 3/4]) is 3/4
  list-max([list: -1, -2, -3])  is -1
  list-max(empty) is 0
end
</pre>

<p>
Now we have to make design decisions, should it eval to 0 for empty since the max of an empty list is nothing or should it raise an error?
</p>

<pre class="example">
fun list-max(lon :: List&lt;Number&gt;) -&gt; Number:
  if lon == empty:
    raise("List can't be empty")
  else:
    fold(lam(acc, n): if n &gt; acc: n else: acc end end, lon.get(0), lon)
  end
where:
  list-max([list: -1, 1, 2]) is 2
  list-max([list: 0, -100, 1]) is 1
  list-max([list: 1/2, 3/4]) is 3/4
  list-max([list: -1, -2, -3])  is -1
  list-max(empty) raises "List can't be empty"
end
</pre>
</details>

<p>
Write your own fold 
</p>

<details>
<pre class="example">
fun my-fold&lt;T&gt;(func :: (T, T-&gt; T), acc :: T, l :: List&lt;T&gt;) -&gt; T:
  cases (List) l:
    | empty =&gt; acc
    | link(f, r) =&gt;
      my-fold(func, func(acc, f), r)
  end
end
check:
  my-fold((lam(acc, elt): acc + elt end), 0, [list: 3, 2, 1]) is 6
  my-fold((lam(acc, elt): acc + elt end), 10, [list: 3, 2, 1]) is 16
  fun combine(acc, elt) -&gt; String:
    tostring(elt) + " - " + acc
  end
  my-fold(combine, "END", [list: 3, 2, 1]) is "1 - 2 - 3 - END"
  my-fold(combine, "END", empty) is "END"
end
</pre>
</details>

<p>
<b>Map2</b>
</p>

<p>
Try the task for implementing who-passed, the second task we're asked to write map2 ourselves. 
</p>

<details>
<pre class="example">
# link(ff, rr) and link(f, r) can be called anything:
# ie: link(head-first, tail-first) or link(head-second, tail-second)

fun my-map2&lt;T&gt;(func :: (T, T -&gt; T), list1 :: List&lt;T&gt;, list2 :: List&lt;T&gt;) -&gt; List&lt;T&gt;:
  cases (List) list1:
    | empty =&gt; empty
    | link(f, r) =&gt;
      cases (List) list2:
        | empty =&gt; empty
        | link(ff, rr) =&gt;
          link(func(f, ff), my-map2(func, r, rr))
      end
  end
end
check:
  my-map2(string-append, [list: "mis", "mal"], [list: "fortune", "practice"])
    is [list: "misfortune", "malpractice"]
  my-map2(_ + _, [list: "mis", "mal"], [list: "fortune", "practice"])
    is [list: "misfortune", "malpractice"]
  my-map2(string-append, [list: "mis", "mal"], [list: "fortune"])
    is [list: "misfortune"]
  my-map2(string-append, [list: "mis", "mal"], empty)
    is empty
end
</pre>
</details>

<p>
The last task, best-price, look on youtube what a basic demand function is. Here's an example:
</p>

<pre class="example">
fun demand(price-increase :: Number) -&gt; Number:
 doc: "1000 is approx demand of product at a fixed price"
  1000 - (60 * price-increase)
end
</pre>

<p>
This means as the price increases, the quantity demanded will decrease by 60 units times the price increase, so if the price increase is 1, the demand is 1000 - 60. Your best-price function can take a list of price increases, the demand function, then map over the price list w/the demand function, to get a new list of adjusted demand vs price increase. Map over the adjusted demand with the price list to produce the forecast revenue, which is price * qty demanded. Then figure out how to use a combo of filter/fold in order to return the optimal price increase.
</p>

<p>
<b>Map vs Filter vs Foldl vs Foldr</b>
</p>

<p>
map and filter only consider one item at a time whereas fold can consider the entire list. You can implement both map and filter with fold (try it). If you've noticed in the Pyret documentation there is two folds: foldl and foldr:
</p>

<pre class="example">
import lists as L

L.foldl(lam(acc, x): acc + x end, 0, [list: 1, 2, 3])
# (((0 + 1)+ 2)+ 3)
# eval nested brackets first, left to right

L.foldr(lam(acc, x): acc + x end, 0, [list: 1, 2, 3])
# (1 +(2 +(3 + 0)))
# eval nested brackets right to left
</pre>
</div>
</div>
</div>

<div id="outline-container-org44f40f7" class="outline-2">
<h2 id="org44f40f7">Requirements Analysis</h2>
<div class="outline-text-2" id="text-org44f40f7">
<p>
It may be helpful to look at some pdfs on software <a href="https://www.cs.cornell.edu/courses/cs5150/2019sp/lectures.html#D">requirements</a>, ie: what is it we are actually building. There's many of these kinds of <a href="https://cmu-313.github.io/?#schedule">development foundations</a> style courses around that are worth looking through to better understand how to read requirements, or if you're just curious about modern methologies in building software. We aren't going to be doing requirements modelling or anything but some of the info here will help you with reading what the assignments are actually asking for us to build. 
</p>
</div>
</div>


<div id="outline-container-org9ed918e" class="outline-2">
<h2 id="org9ed918e">Assignment 1: DocDiff</h2>
<div class="outline-text-2" id="text-org9ed918e">
<p>
Let's try the first <a href="https://cs.brown.edu/courses/cs019/2018/docdiffdocdiff.html">assignment</a>. We can access the assignments before 2019, because the 2020 assignments have a different IDE requiring a brown student login, you'll see what it looks like and why a sign-in is needed in the paper we read next.
</p>
</div>

<div id="outline-container-orgcc35b5e" class="outline-3">
<h3 id="orgcc35b5e">A study about us, beginner students</h3>
<div class="outline-text-3" id="text-orgcc35b5e">
<p>
Before you begin, it will be helpful to read Prof K's <a href="https://cs.brown.edu/~sk/Publications/Papers/Published/wk-stud-write-test-no-coercion/">paper</a> about these same cs19 assignments which will tell us why this course is set up the way it is in the first place, what he expects and how he grades these assignments. In the introduction he bluntly informs us that we lack the metacognitive awareness at the beginner stage to self-regulate our progress. Various attempts to fix this have been tried like Polya's <i>How to Solve It</i> problem solving book or his own book <i>How to Design Programs</i> which uses the design recipe template to help beginning students. We as students are supposed to reinterpret the problem ourselves so we actually understand it by writing examples or walking through the design recipe. 
</p>

<p>
Section 2 <i>Pedagogic Context</i> begins to talk about this same course we are doing. He extracts the students tests and runs them against known buggy implementations to see how thorough they are. There's a picture of the new sign-in IDE it's the same CPO except included is a shared g-drive library that tell you your testing progress. This is included to 'coerce' students to write more tests with interactive feedback. He even ran statistics on when students click run in the interpreter.  
</p>

<p>
5.2 tells us exactly how to start these assignments: write 'interesting' examples prior to any implementation. Interesting means an assertion that probes our understanding of the problem. 
</p>
</div>
</div>

<div id="outline-container-org4a96d7d" class="outline-3">
<h3 id="org4a96d7d">DocDiff</h3>
<div class="outline-text-3" id="text-org4a96d7d">
<p>
So now we know what we need to do: write examples that help our understanding and these should be thorough meaning covering the whole problem domain. Let's try DocDiff assignment. 
</p>

<p>
This <a href="https://cs.brown.edu/courses/cs019/2018/docdiffdocdiff.html">assignment writeup</a> seems purposely difficult to get us to write examples to help understand what the assignment wants. The <a href="https://en.wikipedia.org/wiki/Dot_product#Algebraic_definition">dot product</a> algebraic definition, look at the example for [1,3,-5] x [4,-2,-1]. Each index in the first list is multiplied by it's corresponding index in the second list, then those results are added together. To read the sigma notation, a*b = the sum of \(a_ib_i\) starting at index 1 (first element of the list) up to the length of the list (n). If a = [1,3,-5] and b = [4,-2,-1]:
</p>

<p>
\(a*b = \sum_{i=1}^3 a_ib_i\) = (\(1_{a1} * 4_{b1})+(3_{a2} * -2_{b2})+(-5_{a3} * -1_{b3})\)
</p>


<p>
Some more requirements are listed, such as ignoring the case (upper/lower) of a word when counting it's number of occurrences. The exact equation for overlap is given that needs to be translated to a program. 
</p>

<p>
Example vectors:
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">test</td>
<td class="org-right">zest</td>
</tr>

<tr>
<td class="org-left">[list: "test"]</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">[list: "zest"]</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
Before we begin see the Pyret <a href="https://www.pyret.org/docs/latest/Pyret_Style_Guide.html">style guide</a>. 
</p>

<p>
Let's start with create-vec() since we were given examples in the assignment writeup, scroll down the assignment writeup and click 'Implementation' you should get <a href="https://code.pyret.org/editor#share=1s-chFIEAeCKvIsYnstqRxqOBtiodMPme&amp;v=7aff971">this</a> which makes it clear they just want a single function called overlap, but we can fill it with helper functions like create-vec:
</p>

<pre class="example">
fun create-vec(l-a :: List&lt;String&gt;, l-b :: List&lt;String&gt;) -&gt; List&lt;Number&gt;:
  doc: "Consumes two lists and returns a vector representation of the first input (l-a)"
  ...
where:
  create-vec([list: "a", "B", "c"], [list: "d", "d", "d", "b"]) is [list: 1, 1, 1, 0] 
  create-vec([list: "d", "d", "D", "b"], [list: "a", "b", "c"]) is [list: 0, 1, 0, 3]
end

</pre>

<p>
Write examples what you think it should produce. How do you sort the vector representation is it alphabetical (you can use built-in .sort() for this) is one test to write. Practice writing create-vec in several ways, for example a vector looks a lot like table data. Let's make one using the above given example for [list: "a", "B", "c"], [list: "d", "d", "D", "b"]) is [list: 1, 1, 1, 0]  
</p>

<pre class="example">
vector = table: word, count
  row: "a", 1
  row: "b", 1
  row: "c", 1
  row: "d", 0
end
vector.get-column("count") # this returns: [list: 1, 1, 1, 0]
</pre>

<p>
You could then write a helper function inside create-vec that takes the distinct and sorted concatenation of both input lists to produce a vector table, I found this in the Pyret documentation:
</p>

<pre class="example">
  fun helper(distinct-list :: List&lt;String&gt;, vec-table :: Table) -&gt; Table:
    cases (List) distinct-list:
      | empty =&gt; vec-table
      | link(f ,r) =&gt; helper(r, vec-table.add-row(vec-table.row(f, count(f))))
    end
  end
...
... stuff here in create-vec()
where:
  create-vec([list: "a", "B", "c"], [list: "d", "d", "d", "b"]).get-column("count") is [list: 1, 1, 1, 0] 
  create-vec([list: "d", "d", "D", "b"], [list: "a", "b", "c"]).get-column("count") is [list: 0, 1, 0, 3]
  create-vec([list: "word1", "word3"], [list: "word2"]).get-column("count") is [list: 1, 0, 1]
# check if sorted properly, this would need more testing
  create-vec([list: "aaab", "aaaab"], [list: "aab", "aaab"]).get-column("count") is [list: 1, 1, 0]
end
</pre>

<p>
Or you could play around with making a vector data type, then you can build whole lists of vectors and map through the list to do cases on vectors
</p>

<pre class="example">
data Vector:
  | vec(
      words :: List&lt;String&gt;,
      total-words :: List&lt;String&gt;,
      occurence :: List&lt;Number&gt;)
end

vector-1 = vec([list: "a", "B", "c"], [list: "a", "b", "c", "d"], [list: 1, 1, 1, 0]) 
vector-1.occurence # produces [list: 1, 1, 1, 0]
</pre>

<p>
Or use map/filter/fold on lists, produce a distinct list and then as you map through each element (which will be a word), call another function count(x) to count how many times that word appeared. The point here being you can represent it as anything so experiment with whatever you want. To square a vector write a dot-product function to multiply and sum a vector by itself ie: dot-product(doc1, doc1), then translate the overlap formula with <a href="https://www.pyret.org/docs/latest/numbers.html#(part._numbers_num-sqrt)">built-ins</a>. The overlap function will return a <a href="https://www.pyret.org/docs/latest/numbers.html#(part._.Number_.Literals)">roughnum</a> because of the ways computers repesent real numbers using floating point, so you will never get enough precision to test the output of overlap with pre-calculated value. You can however measure the displacement between the output of overlap, and your expected test value meaning if you subtract them both the absolute value of their difference should be within some tiny arbitrary displacement you decide on the precision for like .000001 and use 'is-roughly' for testing.  
</p>
</div>
</div>
</div>

<div id="outline-container-orgd967eff" class="outline-2">
<h2 id="orgd967eff">Lecture 4 CS019 Big-O</h2>
<div class="outline-text-2" id="text-orgd967eff">
<p>
Watching the Fri 9/14/18 lecture on performance. The setup in the beginning of the lecture is to distinguish the notation in O(n) as being a function that maps from n -&gt; steps to complete computation. Another explanation is <a href="https://cs.uwaterloo.ca/~plragde/flaneries/FDS/Tools_and_Techniques.html#(part._.Ambiguities_in_mathematics)">here</a> in <i>ambiguities in mathematics</i>.  
</p>

<p>
The constant mentioned at the end of the lecture in the formal notation is further exampled <a href="https://cs.uwaterloo.ca/~plragde/flaneries/FDS/Tools_and_Techniques.html#(part._.A_formal_definition)">here</a>. It's an estimation constant that bounds f, so no matter what input to f(k), a constant c times g(k) will be bigger or equal to it. What times g(k) is bigger or equal to f(k) -&gt; 5k + 4:
</p>

<ul class="org-ul">
<li>f(k) -&gt; 5k + 4:
<ul class="org-ul">
<li>f(1) -&gt;  5(1) + 4 = 9</li>
<li>f(2) -&gt;  5(2) + 4 = 14</li>
<li>f(3) -&gt;  5(3) + 4 = 19</li>
<li>f(10) -&gt; 5(10) + 4 = 54</li>
</ul></li>

<li>g(k) -&gt; k:
<ul class="org-ul">
<li>g(1) = 1</li>
<li>g(2) = 2</li>
<li>g(3) = 3</li>
</ul></li>
</ul>

<p>
The constant c, try 10 as suggested in the lecture for f([k -&gt; 5k + 4]) is \(\le\) (10 * g([k -&gt; k)):
</p>

<ul class="org-ul">
<li>f(1) is 9</li>
<li>g(1) -&gt; 10 * g(1) is 10 
<ul class="org-ul">
<li>f &lt; g</li>
</ul></li>
<li>f(2) is 14</li>
<li>g(2) -&gt; 10 * g(2) is 20 
<ul class="org-ul">
<li>f &lt; g</li>
</ul></li>
<li>f(10) is 54</li>
<li>g(10) -&gt; 10 * g(10) is 100 
<ul class="org-ul">
<li>f &lt; g</li>
</ul></li>
</ul>
</div>


<div id="outline-container-org6a92e32" class="outline-3">
<h3 id="org6a92e32">Reading Chapter 17</h3>
<div class="outline-text-3" id="text-org6a92e32">
<p>
We're reading <a href="https://papl.cs.brown.edu/2019/predicting-growth.html">Predicting Growth</a> following the last cs019 lecture on complexity. 
</p>

<p>
17.5 <i>structural recursion</i> can be described as you have built up a structure like say a list, adding n + 1 elements and structural recursion is taking that structure apart in the same way you built it up, recurring on (n - 1) like counting it's length, whereas <i>generative</i> recursion rearranges a problem into a set of new generated problems, basically recursion that <a href="https://htdp.org/2018-01-06/Book/part_five.html">ignores structure</a>. Quick sort is an example of generative recursion you break on a pivot and now have 2 lists plus the pivot, that's not how you assembled that list structurally. 
</p>

<p>
The Tabular Method, is not necessary as you will read in 17.8 since we can hand count these functions like we learned in the lecture. The 'question' refers to the conditionals in the cases statement like empty? and the answer is what that datatype variant evaluates to, like empty, or 0 or the recursive call in link(f, r). 
</p>

<p>
"<i>Let's consider the first row. The question costs three units (one each to evaluate the implicit empty-ness predicate, l, and to apply the former to the latter)</i>" which is a very difficult way of saying: calling the function is +1 cost, opening up l for cases is +1, considering empty variant is +1, so 3 in total and once more if the list is actually empty which you should remember from lecture 4 Fri/9/14/18. Second row cost calculation is different from the lecture (none of these tiny costs matter of course), We get to link(f, r) and count: link +1, f + 1, rest + 1, 2 more for the addition operation, and one more to call len() again, so total 6 for the 'answer' though the lecture we saw is +1 for link, +1 for addition, and plus (k - 1), so in the lecture len() is total 5k + 4, here it's 12k + 4. You can do either this tabular method or you can do the adhoc assign + 1 cost to anything that looks like an operations that we did in the lecture and you will end up with O([k -&gt; k]) anyway since we don't care about constants. 
</p>

<p>
17.7 We've seen this notation in lectures, they are lambda functions to remove ambiguities of math notation. 14.8 recall from lectures that in english reads: 'there exists some constant C, for all inputs n in the set of Natural Numbers to the function f(n) such that f(n) is less or equal to this same constant C multiplied by some other function g(n) implying that f() is bounded by g(). 
</p>

<p>
17.8 Let's find the smallest constant for 13k + 4 \(\le\) ck<sup>2</sup>. If k = 1 then c needs to be 17 or larger. If k = 2 then we have 30 \(\le\) 17(2<sup>2</sup>) which is true, and also true for k = 3, k = 4, if k = a trillion then 13(1 trillion) + 4 is still less than 17(1 trilllion * 1 trillion) in fact for inputs bigger than 13 the constant c becomes irrelevant. <a href="https://www.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-big-theta-notation">Big theta</a> is then discussed briefly as the family of functions that grow at the same speed up to a constant. Reading PAPL, if you want to understand the math notation right click it, or if on a phone press the notation, in most browsers you should get a menu popping up from MathJax to show the TeX code to see exactly what it is. 
</p>

<p>
17.9 <i>Combining Big-oh Without Woe</i> two functions in O(n) run consecutively (one after the other) are O(n + n) or O(2n) which is O(n) since constants don't matter, like f(5k + 4) is really f(k). A function f(n) that invokes z(n) in each of it's steps is O(n x n) or O(n<sup>2</sup>). 
</p>
</div>

<div id="outline-container-orgcb6296c" class="outline-4">
<h4 id="orgcb6296c">17.10 Solving recurrences</h4>
<div class="outline-text-4" id="text-orgcb6296c">
<p>
The first recurrence example of T(k) = T(k - 1) think of the lecture when we went through length(), which was a constant amount of 5 steps per input, plus everything that came before it, so 5 + (k-1) + 4 with the + 4 being the empty case, that's the same as T(k - 1) + c. The notation T(k - 2), T(k - 3) is referring to the next steps down the recursion tree towards the base case. Here \(c_0\) or \(c_1\) are used to show the base case is either 0 or 1 (the empty/stop recursion case). If you want go through this set of YouTube <a href="https://www.youtube.com/channel/UCZCFT11CWBi3MHNlGf019nw/search?query=recurrence">examples</a> on recurrence relations to see what a recursion tree looks like.  
</p>

<p>
The next recurrence is T(k-1) plus k, not a constant. To understand the notation: \(T(0) + (k-(k-1)) + (k-(k-2)) + \cdots + (k-2) + (k-1) + k\) plug in a value for k:
</p>

<ul class="org-ul">
<li>T(4) = T(0) + T(4-(4-1)) + T(4-(4-2)) + T(4-1) + T(4)</li>
<li>0 + 1 + 2 + 3 + 4</li>
<li>4(4+1)/2 = 10 is the closed form solution and is in O(\(n^2\)) since n(n + 1)/2 = (n<sup>2</sup> + n)/2.</li>
</ul>

<p>
2T notation means there are two recursive calls. The last recurrence relation is detailed in this <a href="https://www.youtube.com/watch?v=JvcqtZk2mng">YouTube</a> example.    
</p>

<p>
There's an induction exercise which you can try if you've followed the math workshop with this one: 
</p>

<ul class="org-ul">
<li>T(n) = n(n + 1)/2</li>
<li>Base Case:
<ul class="org-ul">
<li>T(1) = 1(1 + 1)/2 or 2/2</li>
<li>T(1) = 1</li>
</ul></li>
<li>Hypothesis:
<ul class="org-ul">
<li>Suppose that T(n) = n(n + 1)/2 (assumption)</li>
</ul></li>
<li>Then it is true for n + 1:
<ul class="org-ul">
<li>T(n) + (n + 1) = (n + 1)((n + 1) + 1)/2</li>
<li>T(n) + (n + 1) = (n + 1)(n + 2)/2</li>
</ul></li>
<li>Left side is in the form of hypothesis T(n):
<ul class="org-ul">
<li>n(n + 1)/2 + (n + 1) = (n + 1)(n + 2)/2</li>
</ul></li>
<li>Let's get rid of the denominator 2 by multiplying both sides by 2/1 
<ul class="org-ul">
<li>n(n + 1) + 2(n + 1) = (n + 1)(n + 2)</li>
<li>\(n^2\) + 3n + 2 = (n + 1)(n + 2)</li>
</ul></li>
<li>Factor left side:
<ul class="org-ul">
<li>(n + 1)(n + 2) = (n + 1)(n + 2)</li>
</ul></li>
</ul>

<p>
We will come back to this chapter after next lecture to figure out the [k -&gt; log k] and other logarithmic time algorithms. 
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org203d715" class="outline-2">
<h2 id="org203d715">Lecture 5 CS019 Insertion Sort Reccurrence</h2>
<div class="outline-text-2" id="text-org203d715">
<p>
We're watching the Mon9/17/18 lecture. The first 30mins or so of the recording doesn't have video, but you can pause the video around 30:14 in, open the video again to hear the audio, and see everything on the board they are working on (sort and insert). He starts out talking about the invariant of insert, that it's length should always be k+1 because it is inserting a new value. The second topic is about how the size argument of a list doesn't help you with incorrect types, if you have [list: [list: empty]], that's still size = 1 even though it's empty. 
</p>

<p>
The if-statement you take the worst complexity branch, assuming worse-case analysis. The actual cost analysis of insert() starts around 20mins in because you want to resolve the dependencies of sort() by figuring out the complexity class of insert() first. A link operation link(f, r) takes a constant amount of time regardless of the size of the input list, because it doesn't make a copy of the list. The if statement is 1 + (worst case branch). 
</p>

<p>
On the right hand of the board:
</p>
<ul class="org-ul">
<li>Tinsert(0) = \(c0\) (constant steps for empty, or base case)</li>
<li>Tinsert(k) = c + Tinsert(k - 1)</li>
<li>= c + c + c + &#x2026; \(c0\)</li>
<li>= T(k) = kc + \(c0\).</li>
</ul>

<p>
Remember we're calling insert(f, sort(r)) on the rest of the list, so it's k - 1. 
</p>

<ul class="org-ul">
<li>Tsort(0) = \(c_0\) or a constant amount of steps</li>
<li>Tsort(k) = Tsort(k - 1) + Tinsert(k - 1)c + \(c_0\)</li>
<li>= Tsort(k - 1) + kc</li>
<li>We've seen this already, T(k - 1) + k is the series 1 + 2 + 3 + 4+&#x2026;+(k - 1) + k or n(n + 1)/2 or \(O(n^2)\)</li>
<li>Insertion Sort is \(O(n^2)\) worst case, and O(n) + O(1) in the best case because you still have to call sort(r) and do linear work exploding that n sized list out before you can do the O(1) operation by insert that appends to the beginning of the list and returns.</li>
</ul>
</div>


<div id="outline-container-org70b324a" class="outline-3">
<h3 id="org70b324a">More Recurrences</h3>
<div class="outline-text-3" id="text-org70b324a">
<p>
Before we look at the big-O lab let's learn some more about recurrences so we 'can feel them in our bones' as suggested by Prof K in the last lecture. I'm going to use Part V <i>Recurrences</i> from MIT's <a href="https://courses.csail.mit.edu/6.042/spring18/mcs.pdf">Mathematics for Computer Science(mcs)</a> free book, starting on page 993 and read only up to page 1001 as cs019 will cover the analysis later (Akra-Bazzi formula/asymptotic solution) in future lectures. For now we're going to read the intro of the Tower of Hanoi, and the steps they do to solve the recurrence for merge sort. 
</p>

<p>
There are <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/video-lectures/lecture-14-divide-and-conquer-recurrences/">lectures</a> for the recurrence chapter of mcs, the inductive proof in the recorded lecture for the Tower of Hanoi recurrence is slightly different than the pdf:
</p>

<ul class="org-ul">
<li>Our original recurrence: \(T_n\) = 2\(T_{n-1}\) + 1</li>
<li>Inductive Hypothesis(IH)/closed form solution: \(T_n\) = \(2^n\) - 1</li>
<li>Base Case: \(T_1\) = \(2^1\) - 1</li>
<li>Inductive step: \(T_{n+1}\) = 2\(T_{(n-1) + (n+1)}\) + 1 or 2\(T_n\) + 1</li>
<li>"Suppose \(T_n\) = \(2^n\) - 1. Then the successor of \(T_n\) is \(T_{n+1}\) = \(2^{n+1}\) - 1"</li>
<li>Now via substitution plug in our inductive hypothesis, since we declared \(T_n\) = \(2^n\) - 1 wherever you see \(T_n\) insert that hypothesis:
<ul class="org-ul">
<li>\(T_{n+1}\) = 2\(T_n\) + 1</li>
<li>\(T_{n+1}\) = 2(\(2^n\) - 1) + 1 (substitution)</li>
<li>\(T_{n+1}\) = \(2^{n+1}\) - 2 + 1 (distributive law)</li>
<li>\(T_{n+1}\) = \(2^{n+1}\) - 1</li>
</ul></li>
</ul>

<p>
In mcs (the pdf text), for their IH they assumed that \(T_{n-1}\) = \(2^{n-1}\) - 1, so instead of substituting for \(T_n\) they substituted \(T_{n-1}\):
</p>

<ul class="org-ul">
<li>Original recurrence: \(T_n\) = 2\(T_{n-1}\) + 1</li>
<li>Assume/IH: \(T_{n-1}\) = \(2^{n-1}\) - 1</li>
<li>Inductive step (looking at the left side) from \(T_{n-1}\) to \(T_{n++}\) becomes \(T_n\), and we already know the value: \(T_n\) = 2\(T_{n-1}\) + 1</li>
<li>By substitution replace all occurrences of \(T_{n-1}\) with IH:
<ul class="org-ul">
<li>\(T_n\) = 2(\(2^{n-1}\) - 1) + 1</li>
<li>\(T_n\) = \(2^n\) - 2 + 1</li>
<li>\(T_n\) = \(2^n\) - 1</li>
</ul></li>
</ul>

<p>
In <i>Merge Sort</i>, \(T_n\) describes two recursive calls, with the total input divided in half between them, plus another recursive call to compare each list and produce the smaller value (merging). The plug and chug method they use is self explanatory until Step 3 where they introduce k = log n in order to get their base case of \(T_1\) = 0. When you see \(2^k\) anywhere in the recurrence replace it with \(2^{\log n}\) which is n because \(a^{\log b}\) = \(b\). What you should take away from step 3 is how they manipulate the recurrence in order to produce a known value of \(T_n\) such as \(T_0\) or \(T_1\) in this case.
</p>


<p>
Step 3, after k = log n has been substituted for all k:
</p>
<ul class="org-ul">
<li>\(2^{\log n}T_{n/2^{\log n}}\) + log n * n - \(2^{\log n}\) + 1
<ul class="org-ul">
<li>Remember \(2^{\log n}\) = n</li>
</ul></li>
<li>n\(T_{n/n}\) + n * log n - n + 1
<ul class="org-ul">
<li>n\(T_{n/n}\) is n\(T_1\) and in step 3 \(T_1\) was already declared to be 0</li>
</ul></li>
<li>n(0) + n * log n - n + 1</li>
<li>n log n - n + 1 or \(T_n \in O(n \log n)\)</li>
</ul>
</div>
</div>

<div id="outline-container-org8d076ce" class="outline-3">
<h3 id="org8d076ce">Return to 17.10 Recurrences</h3>
<div class="outline-text-3" id="text-org8d076ce">
<p>
Let's go back and <a href="https://papl.cs.brown.edu/2019/predicting-growth.html">read</a> 14.10 <i>Solving Recurrences</i> again now that we know how logarithms are used to produce a known base case value, like \(T_1\). The first is T(k) = T(k/2) + c or [k -&gt; log k] recurrence, we are looking at binary search. For this binary search example, note the trick to make this recurrence \(T_1\) and look up how the logarithms are <a href="https://en.wikipedia.org/wiki/Logarithm#Definition">defined</a> for \(log_2\) k. 
</p>

<p>
The next example T(k) = T(k/2) + k or [k -&gt; k], again they have used the \(2^{\log k}\) trick to produce k/k, and they have also used the distributive property to factor out k producing k(1/k + &#x2026;+ 1/4 + 1/2 + 1) which ends up simplifying to base case 1 constant + 2k. The [k -&gt; k log k] example they get rid of \(2^k\) by replacing it with \(2^{\log k}\) which is k and this is multiplied by T(1) which is \(c_1\). The rest of the recurrence is k \(\log_2\) k which is exampled and explained in this article on <a href="https://en.wikipedia.org/wiki/Logarithm#Product,_quotient,_power,_and_root">power rule</a>. \(\log_2 k^k\) is k \(\cdot\) \(log_2\) k or k.  
</p>
</div>
</div>

<div id="outline-container-org5489972" class="outline-3">
<h3 id="org5489972">Lab: Big-O 1</h3>
<div class="outline-text-3" id="text-org5489972">
<p>
Let's go through the lab <a href="https://cs.brown.edu/courses/cs019/2016/bigO-lab.pdf">here</a>. 
</p>

<p>
First task, why can we disregard constants, we already know why, because g(x) = 5x<sup>2</sup> + x is T(k) = T(k-1) + n which is O[k -&gt; k<sup>2</sup>]), since we only care (in this class anyway) about finding an upper bound for the worse case, we don't care about the constant 5 or x as they are both bound by x<sup>2</sup>. We've seen how when inputs grow large, x<sup>2</sup> grows so much that x and any constants are insignificant numbers (solely for worse case analysis of course).  
</p>

<p>
Second task in the chapter <i>Notation</i> notice the brackets are needed if using the [k -&gt; k] notation and is why the first example of O(w -&gt; w<sup>3</sup>) is wrong, it should be f \(\in\) O([w -&gt; w<sup>3</sup>]). There also shouldn't be any constants in the notation like [m -&gt; 3m]. The example of f \(\in\) O(h<sup>2</sup>) should likely be f \(\in\) O([h -&gt; h<sup>2</sup>]) or f(h) \(\in\) O(h<sup>2</sup>). 
</p>

<p>
In 3 <i>The Tabular Method</i> we finally get an explanation what the terms 'question' and 'answer' mean, this should probably be in the book. The second row of the cases statement we already read in the book for len function, and saw it in lectures. It really doesn't matter how you count the constant units either for worse case analysis, in lectures we chose link(f, r) as +1 cost, the addition as +1 cost, and added it to 3k + 4 so total 5k + 4. If you carefully counted each operation in link and came up with 100k + 4 it'd still be the same worst case analysis of len() is in O([k -&gt; k]). Looking back at chapter <a href="https://papl.cs.brown.edu/2018/predicting-growth.html#(part._solving-recurrences)">14</a> T(k) = T(k - 1) + c recurrence is the same as len(). 
</p>


<p>
4 <i>Big-O with less math</i> explains how to estimate complexity a little more clearly than the book does. Task:
</p>


<ul class="org-ul">
<li>1: This could be [k -&gt; k * log k] because for each element we make a call to another function so O(F X G). This also fits the explanation of f(x) = x log x where the recursive call is logarithmic but input stays the same.</li>
<li>2: This could be [n -&gt; n + m] which is [n -&gt; n]</li>
<li>3: This could be [k -&gt; k * m<sup>2</sup>] which is [k -&gt; k<sup>3</sup>]</li>
<li>4: This is 'a function makes calls to another function at every one of it's steps' so O(F X G) as we are linearly going through to-delete, and at each element f, we call remove(f) on another list (remove(f) then needs to linearly go through all of l to remove f).</li>
</ul>

<p>
Let's figure out 5, a function that takes input 2 lists and counts their length. This translates to two nested cases:
</p>

<pre class="example">
fun dbl-count(list1, list2):
 cases (List) list1:
  | empty =&gt; 0
  | link(f, r) =&gt;
 cases (List) list2:
  | empty =&gt; 0
  | link(ff, rr) =&gt; 1 + dbl-count(r) + 1 + dbl-count(rr)
  end
 end
end   
</pre>

<p>
Looking at chapter 17 in the book, this is T(k) = 2T(k - 1) + c. Two recursive calls each doing a constant amount of work. Let's confirm by watching <a href="https://youtu.be/JvcqtZk2mng">T(n)=2T(n-1)+1</a>. Indeed this is O([k -&gt; k<sup>k</sup>]).
</p>

<ul class="org-ul">
<li>6: My guess is that this is O(F(k) X G(k) X H(k<sup>2</sup>)) or O([k -&gt; k<sup>4</sup>])</li>
<li>7: Recall from lectures that you figure out complexity cost of dependent functions from the function dependencies up, so we want to find the cost for rem-helper() first. It takes a size k input, and an element from rem-dups. We have an if-branch so we take the worst branch, and both branches involve going linearly through the entire list and looking at every element. We'll just naively calculate some costs: We go into the function, +1, we open the list, +1, we look at empty case, +1, it is empty and we return empty so 3k + 1. If it's not empty +1 for link operation, +1 to compare f to c, and worst case I guess is +1 to link f then + all the previous operations all over again until empty. So this is k + constant or O([k -&gt; k]). Let's look at rem-dups. It's doing linear work up until it calls rem-helper() on every single element. The definition of Quadratic: 'appears when comparing each element of a data structure to all other elements in that structure'  seems to fit this situation, so O([k -&gt; k<sup>2</sup>]). Looking in the book, we see T(k) = T(k - 1) + k describes this program as well.</li>
</ul>

<p>
5.1 Recall \(c_0\) represents the base case T(0) which is some constant amount of work. 
</p>

<p>
Another task, find the closed form of T(k-2) + 1 if k &gt; 1. There's a lecture for <a href="https://www.youtube.com/watch?v=8gt0D0IqU5w">this</a>.
</p>

<p>
Second recurrence relation: 2T(k-1) + 1 for k &gt; 0 we already did, it's O([k -&gt; k<sup>k</sup>]). The extra challenge relations are all in the book and lectures to solve these exist in this guy's <a href="https://www.youtube.com/playlist?list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O">playlist</a> under 2.1.1 - 2.3.3. 
assertion is true. If you get stuck on the nested conditionals question notice the @requries x &lt; 10, and if 4 &lt; x makes the nested x &lt;= 16 statement a waste of code. Let's continue on to the <i>Assignments</i> module, the example of if (e &gt; 0) { e = e - 1;.. note again these are integers, so the input can't be 0.5 or a 'half number' that makes e negative after 1 is subtracted. This is a little confusing because they are mixing assignment statements '=' with equality statements in working out their point-to reasoning. The very last assignment took some word smithing, x' + y' &gt; 2 * n. The last question to rewrite the assertion without using primed variables substitute exactly what x and y are into x + y &gt; 2 * n, which is (x * 2) + x &gt; 2 * n. 
</p>
</div>
</div>
</div>

<div id="outline-container-org7e7c866" class="outline-2">
<h2 id="org7e7c866">Lecture 6 CS019 Quicksort</h2>
<div class="outline-text-2" id="text-org7e7c866">
<p>
We're watching the lecture titled Wed9/19/18. Reminder these lectures can be viewed or downloaded in 1920x1080 size so you can zoom with whatever video player if needed but seeing the fine details isn't important he is showcasing the structure of linear [k -&gt; k] vs quadratic [k -&gt; \(k^2\)].  
</p>

<p>
He remarks that their quicksort implementation is really a filter, and we should try quicksort using a built-in. Let's try it:
</p>

<pre class="example">
fun combine(lt, p, gt):
  lt.append([list: p]).append(gt)
end

fun qsort(l):
  cases (List) l:
    | empty =&gt; empty
    | link(pivot, r) =&gt;
      combine(
        qsort(r.filter(lam(n): n &lt; pivot end)),
        pivot,
        qsort(r.filter(lam(n): n &gt;= pivot end)))
  end
end
check:
  qsort([list: 2, 1, 3, 4, 5]) is [list: 1, 2, 3, 4, 5]
  qsort([list: 100, 0, 1, 343]) is [list: 0, 1, 100, 343]
  qsort([list: 0, -1, 100]) is [list: -1, 0, 100]
  qsort([list: ]) is ([list: ])
  qsort([list: 8, 1, 1, 9, -1]) is [list: -1, 1, 1, 8, 9]
end
</pre>

<p>
He ends the lecture trying to convey a bigger idea: use the structure of the data to come up with a simple solution, confirm the inefficient solution is correct, optimize it according to the bound you want. 
</p>
</div>
</div>


<div id="outline-container-org7b8ce5b" class="outline-2">
<h2 id="org7b8ce5b">Assignment 2: Nile</h2>
<div class="outline-text-2" id="text-org7b8ce5b">
<p>
Here we are restricted from using list built-ins, so member, append, or distinct you'll have to write these yourself though PAPL already gives you uniq in chapter 10. The instructor considers rewriting library functions as drill exercises since programming is learn by doing. We need to fill in recommend and popular-pairs according to the <a href="https://cs.brown.edu/courses/cs019/2019/nilenile.html">spec</a> we're given. Don't use their 2018 starter template, there's some kind of bug where accessing the content of a recommendation doesn't work. Write your own or use <a href="https://code.pyret.org/editor#share=0Bxr4FfLa3goOMmI2RnlkWUhCTzA">this</a>:
</p>

<pre class="example">
provide *
provide-types *

data Recommendation&lt;A&gt;:
  | recommendation(count :: Number, content :: List&lt;A&gt;)
end

data File:
  | file(name :: String, content :: String)
end

fun recommend(title :: String, book-records :: List&lt;File&gt;) -&gt; Recommendation:
  doc: ```Takes in the title of a book and a list of files,
       and returns a recommendation of book(s) to be paired with title
       based on the files in book-records.```
  recommendation(0, empty)
end

fun popular-pairs(records :: List&lt;File&gt;) -&gt; Recommendation:
  doc: ```Takes in a list of files and returns a recommendation of
       the most popular pair(s) of books in records.```
  recommendation(0, empty)
end
</pre>

<p>
Examples to help understand what the assignment is asking for, you can run this to see if the tests are at least well formed:
</p>

<pre class="example">
fun recommend(title :: String, book-records :: List&lt;File&gt;) -&gt; Recommendation:
  doc: ```Takes in the title of a book and a list of files,
       and returns a recommendation of book(s) to be paired with title
      based on the files in book-records.```
  recommendation(0, empty)
where:
  r1 = file("a", "1984\nCrime and Punishment\nHeaps are Lame\nLord of the Flies")
  r2 = file("b", "1984\nHeaps are Lame\nLord of the Flies")
  r3 = file("c", "1984\nCrime and Punishment\nHeaps are Lame\nCalculus")
  r4 = file("d", "Crime and Punishment\n1984\nLord of the Flies")
  input = [list: r1, r2, r3, r4]

  recommend("1984", input) is recommendation(3, [list: "Heaps are Lame", "Crime and Punishment", "Lord of the Flies"])
  recommend("Heaps are Lame", input) is recommendation(3, [list: "Crime and Punishment", "1984", "Lord of the Flies"])
  recommend("War", [list: file("q", "War\nPeace")]) is recommendation(1, [list: "Peace"])
  recommend("PAPL", input) is  recommendation(0, empty)
 

  # These are their tests from 2016 Nile writeup:
  f1=file("alist.txt","1984\nAnimal Farm\nHigurashi\nLife of Pi")
  f2=file("blist.txt","Animal Farm\nHigurashi\nLife of Pi")
  f3=file("clist.txt","1984\nHeart of Darkness")
  input2 = [list: f1, f2, f3]

  recommend("1925", input2) is recommendation(0,[list: ])
  recommend("1984", input2) is recommendation(1,[list: "Animal Farm","Higurashi","Life of Pi","Heart of Darkness"])
end
</pre>

<p>
Again you can do whatever you want here like in DocDiff, my strategy is map through the input, extract the file.content string of "Title\nTitle", and return a single list of all titles that have been recommended.  
</p>

<pre class="example">
fun recommend(title :: String, book-records :: List&lt;File&gt;) -&gt; Recommendation:

 list-of-titles = fold(lam(acc, elt): acc.append(elt) end, empty, map(lam(x): make-list(title, x) end, book-records))
 produce-rec(list-of-titles)
where
.. tests
end 
</pre>

<p>
I wished for a function called make-list(), fed into a fold to append the return into a single [list: "title", "title"]:
</p>

<pre class="example">
# note recommend(title, book-records) are in scope here, if make-list is inside recommend
# you can change parameters to make-list(f :: File) and freely use title inside body of make-list 

fun make-list(search-title :: String, f :: File) -&gt; List&lt;String&gt;:
  doc: "Tests if title is recommended, returns filtered list of f.content minus searched for title"

  new-list = f-to-list(f.content)
  if new-list.member(search-title):
    filter(lam(x): if x == search-title: false else: true end end, new-list)
  else:
    empty      
  end
where:
# ... other tests omitted
  make-list("A", file("", "A\nB\nC")) is [list: "B", "C"]
end

</pre>

<p>
Another wished for function, f-to-list() which I expect extracts the f.content string, converts to a list and returns so it can be tested for membership. Notice I left the input to f-to-list() a single input, and the helper inside deals with accumulators/appending the newline character. 
</p>

<pre class="example">
fun f-to-list(s :: String) -&gt; List&lt;String&gt;:
  doc:" Consumes string Title\nTitle and returns [list: Title, Title]"

  fun helper(acc, l-a):
    doc: "Breaks on newline character and links accumulator"
    cases (List) l-a:
      | empty =&gt; empty 
      | link(f, r) =&gt; 
        if f == 10:
          link(string-from-code-points(acc), helper(empty, r))
        else:
          helper(acc + [list: f], r)
        end
    end
  end
  helper(empty, string-to-code-points(s + "\n"))
where:
  f-to-list("1984\nHeart of Darkness") is [list: "1984", "Heart of Darkness"]
# other tests here..
end
</pre>

<p>
And this is all you do, going on like this writing examples first to understand exactly what the output should be, when you start writing and get to a spot where you wish that your data was in a specific format or that you could accomplish something like counting a total, you insert a function call you haven't created yet wishing for that function, then create a stub for it to remind yourself to fill it in by pasting in the recursive template. You then do the same procedure for the wished for functions, anytime you need something wish for it, write a stub/paste the template. Since Pyret evaluates top down you want to continually drop these function templates above everything else. 
</p>

<p>
When it seems like you've wished your way to the end, pick the smallest and easiest stub and start writing them moving up the chain of easy subroutines. By the time you get to your main functions your program has already been written, at this point you may want to trash everything you did and redo it now that you have a better idea of what needs to be done and this is totally normal.  
</p>
</div>

<div id="outline-container-orgb39fbbf" class="outline-4">
<h4 id="orgb39fbbf">popular-pairs()</h4>
<div class="outline-text-4" id="text-orgb39fbbf">
<p>
Using the 2019 <a href="https://cs.brown.edu/courses/cs019/2019/nilenile.html">Nile</a> assignment spec, notice the new datatype for popular-pairs(), this will be inside a recommendation instead of a list of titles: recommendation(2, [list: pair(book1, book2), pair(book2, book3)] and the return annotation is popular-pairs() -&gt; Recommendation&lt;BookPair&gt;:
</p>
<pre class="example">
data BookPair:
    | pair(book1 :: String, book2 :: String)
end
</pre>

<p>
From the examples you write, the pattern is first paired w/rest, first-of-the-rest paired w/rest-of-the-rest, etc. 
</p>

<pre class="example">
input = [list: file("alist.txt", "1984\nAnimal Farm\nHigurashi\nLife of Pi"),
               file("blist.txt", "Animal Farm\nHigurashi\nLife of Pi"),
               file("clist.txt", "1984\nHeart of Darkness")]

recommendation(2, [list: pair("Animal Farm","Higurashi"), pair("Animal Farm", "Life of Pi"), pair("Higurashi", "Life of Pi")])
</pre>
</div>
</div>
</div>

<div id="outline-container-org6d0d971" class="outline-2">
<h2 id="org6d0d971">Assignment 3: Sortacle</h2>
<div class="outline-text-2" id="text-org6d0d971">
<p>
This assignment we're building a testing oracle.
</p>

<p>
First function is generate-input(n :: Number) -&gt; List&lt;Person&gt;, it consumes a number, and produces a list of length n of type Person. Since this function is going to generate random person.name strings we can't directly match the output in a test case, but we can still confirm it has the correct properties of [list: person(name, number)]:
</p>

<pre class="example">
data Person:
  | person(name :: String, age :: Number)
end

fun generate-input(n :: Number) -&gt; List&lt;Person&gt;:
  doc:"Generate random n size list of person(name, age), name is length 4, age is 1 - 100"
  ...
where:
  # confirm size
  L.length(generate-input(5)) is L.length([list: 1, 2, 3, 4, 5])
  map(lam(x): (string-length(x.name) &gt; 0) is true end, generate-input(5))  

  # make sure the age is within 1 - 100
  map(lam(x): ((x.age &gt; 0) and (x.age &lt;= 100)) is true end, generate-input(5))
 
 # confirm name is ASCII code points from 97 - 122 
 # string-to-code-points() returns a list, so nested map
  map(lam(x): map(lam(y): ((y &gt;= 97) and (y &lt;= 122)) is true end, string-to-code-points(x.name)) end, generate-input(3)) 
end

</pre>

<p>
Pyret has a built-in function for generating a list <a href="https://www.pyret.org/docs/latest/lists.html#(part._lists_repeat)">repeat()</a> which we will need to write ourselves since this assignment doesn't allow using built-ins outside of the higher order functions and sort() or sort-by() though I used some other list built-ins here and in the test cases since we already rewrote them in the Nile assignment. One way we could architect this is recursing on n, linking a list together. So num-random() gives us something resembling a random name, see this <a href="https://en.wikipedia.org/wiki/ASCII">article</a>, code points I guess could be between 97 and 122 or 'a' and 'z' though you could just leave this random and fuzzy test with all unicode code points:
</p>

<details>
<pre class="example">
fun generate-input(n :: Number) -&gt; List&lt;Person&gt;:
  doc:"Generate random n size list of person(name, age)"

  fun random-name(s :: Number, name-string :: String) -&gt; String:
    doc: "Generate a random string between ASCII 97 - 122 of length s"
    if s &lt; 1:
      name-string
    else:
      single = num-random(33) + 90
      if (single &gt;= 97) and (single &lt;= 122):
        random-name(s - 1, string-from-code-point(single) + name-string)
      else:
        random-name(s, name-string)
      end
    end
  where:
    string-length(random-name(5, "")) is 5
    string-length(random-name(1, "")) is 1
  end

  fun helper(num :: Number, acc :: List&lt;String&gt;) -&gt; List&lt;Person&gt;:
    doc: "Consumes n, init acc and returns [list: person(name, age)] n times"    
    if num &lt; 1:
      acc
    else: 
      name-length = num-random(25) + 1
      helper(num - 1, link(person(random-name(name-length, ""), num-random(100) + 1), acc))
     # acc on first call is a placeholder here for empty
     # this will return ...link(item, link(item, orig-acc)) 
    end
  end

  # preconditions
  if n &lt; 1:
    raise("Input must be greater than 0")
  else:
    helper(n, empty)
  end
where:
  # confirm size
  L.length(generate-input(5)) is L.length([list: 1, 2, 3, 4, 5])
  map(lam(x): (string-length(x.name) &gt; 0) is true end, generate-input(2))  

  # make sure the age is within 1 - 100
  map(lam(x): ((x.age &gt; 0) and (x.age &lt;= 100)) is true end, generate-input(2))
  # confirm name is ASCII code points from 97 - 122 
  map(lam(x): map(lam(y): ((y &gt;= 97) and (y &lt;= 122)) is true end, string-to-code-points(x.name)) end, generate-input(2)) 

  # confirm input is &gt; 0
  generate-input(0) raises "Input must be greater than 0"
end
</pre>
</details>

<p>
Now we have what the assignment is looking for:
</p>

<pre class="example">
&gt;&gt;&gt; generate-input(2)
[list: person("vwqukq", 3), person("rljhrsijqcwyuglwjtnhc", 48)]
</pre>

<p>
Next is a sort validation function that consumes two sorted lists of type Person, and compares if they are both the same returning a boolean true or false. To compare if the first sorted input list is equal to the correct sorted list, we could map2 over both lists to do equality tests, then fold over the list map2 returns comparing each entry with 'true'. Note this is inefficient as a case statement can break on the first instance of false instead of continuing through the entire linear list: 
</p>

<details>
<pre class="example">
fun is-valid(test-input :: List&lt;Person&gt;, correct-input :: List&lt;Person&gt;) -&gt; Boolean:
  doc: "Consumes l1 a sorted list and compares to l2 a correct-sorter() list"

  fun length-test(test-input-a :: List&lt;Person&gt;, correct-input-a :: List&lt;Person&gt;) -&gt; Boolean:
    doc: "Test if both lists are the same length"
    (L.length(test-input-a)) == (L.length(correct-input-a))
  end

  fun name-test(test-input-b :: List&lt;Person&gt;, correct-input-b :: List&lt;Person&gt;) -&gt; Boolean:
    doc: "Test if any names have been altered"
    correct-sorted-names = correct-sorter(test-input-b)
    names = map2(lam(n1 :: Person, n2 :: Person): (n1.name == n2.name) end, correct-sorted-names, correct-input-b)
    L.foldl(lam(a :: Boolean, b :: Boolean): a and b end, true, names)
  end

  fun age-sort-test(test-input-c :: List&lt;Person&gt;, correct-input-c :: List&lt;Person&gt;) -&gt; Boolean:
    doc: "Test if sorted by age correctly"
    age-test = map2(lam(n3 :: Person, n4 :: Person): (n3.age == n4.age) end, test-input-c, correct-input-c)
    L.foldl(lam(c :: Boolean, d :: Boolean): c and d end, true, age-test)
  end

  fun age-and-name-sort-test(test-input-d :: List&lt;Person&gt;, correct-input-d :: List&lt;Person&gt;) -&gt; Boolean:
    doc: "See if the names and ages match, this will fail occasionally for qsort on duplicate ages"
    both-test = map2(lam(n5 :: Person, n6 :: Person): (n5.name == n6.name) and (n5.age == n6.age) end, test-input-d, correct-input-d)
    L.foldl(lam(e :: Boolean, f :: Boolean): e and f end, true, both-test)
  end

  # return the results
  if length-test(test-input, correct-input)
    and
    name-test(test-input, correct-input)
    and
    age-sort-test(test-input, correct-input)
    and
    age-and-name-sort-test(test-input, correct-input):
    true
  else:
    false  
  end
where:
  # some corner cases, omitted many tests
  is-valid(empty, empty) is true
  is-valid([list: person("a", 31)], empty) is false
  is-valid([list: person("", 31)], [list: person("a", 31)]) is false 
end
</pre>
</details>

<p>
Now we go about writing multiple buggy implementations of sorting algorithms and test these functions with oracle :: (List&lt;Person&gt; -&gt; List&lt;Person&gt;) -&gt; Boolean ie: oracle(insertion-sort)) or oracle(quick-sort):
</p>

<details>
<pre class="example">
fun combine(lt, p, gt):
  doc: "Used by quicksort"
  lt.append([list: p]).append(gt)
end

fun qsort(l :: List&lt;Person&gt;) -&gt; List&lt;Person&gt;:
  doc: "Quicksort from lectures"
  cases (List) l:
    | empty =&gt; empty
    | link(pivot, r) =&gt;
      combine(
        qsort(r.filter(lam(n): n.age &lt; pivot.age end)),
        pivot,
        qsort(r.filter(lam(n): n.age &gt;= pivot.age end)))
  end
end

fun incorrect-qsort(l :: List&lt;Person&gt;) -&gt; List&lt;Person&gt;:
  doc: "Sabotaged quicksort"
  cases (List) l:
    | empty =&gt; empty
    | link(pivot, r) =&gt;
      combine(
        incorrect-qsort(r.filter(lam(n): n.age &lt; pivot.age end)),
        pivot,
        incorrect-qsort(r.filter(lam(n): n.age &gt; pivot.age end)))
  end
end

# empty case test
fun empty-sort(p :: List&lt;Person&gt;) -&gt; List&lt;Person&gt;: 
  empty 
end

# deletes the names
fun name-screwed(w :: List&lt;Person&gt;) -&gt; List&lt;Person&gt;:
  correct = L.sort-by(w,
    lam(p1, p2): p1.age &lt; p2.age end,
    lam(p1, p2): p1.age == p2.age end)
  (map(lam(x): person("", x.age) end, correct))
end

fun oracle(f :: (List&lt;Person&gt; -&gt; List&lt;Person&gt;))-&gt; Boolean:
  doc: "Testing oracle for sorting lists of type Person"

  random-input = generate-input(num-random(30) + 5)
  is-valid(f(random-input), correct-sorter(random-input))
where:
  oracle(qsort) is true
  oracle(incorrect-qsort) is false
  oracle(name-screwed) is false
  oracle(empty-sort) is false
end
</pre>
</details>

<p>
These tests won't always pass, because sometimes incorrect-qsort() will produce the correct output, it's only on edge cases with duplicate ages that it won't pass our oracle test case. Quicksort will also sometimes produce a different sort sequence for multiple same ages or similar names with different ages that were correctly but differently sorted than the sequence correct-sorter() uses.  
</p>
</div>

<div id="outline-container-org17f5960" class="outline-3">
<h3 id="org17f5960">Check your work against the official solution</h3>
<div class="outline-text-3" id="text-org17f5960">
<p>
Write your solution first, then read this <a href="https://cs.brown.edu/~sk/Publications/Papers/Published/wnk-use-rel-prob-pbt/">pdf</a>. He writes about how this course encourages <a href="http://cs.brown.edu/courses/cs195y/2020/pages/pdf/01.24-propertiesandoracles.pdf">property-based testing</a> which is a way to test properties instead of values and there is a thorough writeup about this sortacle assignment what they graded for and exactly what would fail their tests. 
</p>

<p>
We find out they didn't really care about the generator only that it is a good drill exercise, they primarily tested is-valid extracting only that function to test. They broke the testing down into specific properties is-valid should have and exactly how they implemented their own tests for these properties. 
</p>

<p>
My lazy implementation passed most of their grading tests, as my tests checked if outputs were not the same as inputs (missing names/ages/changed sizes) and although my tests caught whenever correct-sorter hit a corner case like quicksort where duplicate ages could have different order if sorted by age, I didn't handle this false is-valid with additional checks and since these sorts were still valid my implementation would be useless for automated testing. I also sanitized generate-input with checks on valid ages and names but did not check for out of bounds ages in is-valid so would have failed that test too. 
</p>

<p>
The grading tests for oracle assignment (actually, all the assignments) are also in the same paper, don't read it until after you try your own implementation to see if you are picking up these property-based testing techniques, eventually you will.  
</p>
</div>
</div>

<div id="outline-container-org65b07cc" class="outline-3">
<h3 id="org65b07cc">Logic for Systems</h3>
<div class="outline-text-3" id="text-org65b07cc">
<p>
The techniques they used in the paper are taught in their <i>Logic for Systems</i> class which I partially archived with some recorded lectures if you're interested in this kind of logical thinking about programs. We will do something similar later, reasoning about the specifications of programs and their behavior. 
</p>

<pre class="example">
Archive of 195y if you're interested before recorded lectures disappear
magnet:?xt=urn:btih:3187a9951b43b85771a975653680a4a8d9faf61d&amp;dn=195y
</pre>
</div>
</div>
</div>


<div id="outline-container-org0320dbe" class="outline-2">
<h2 id="org0320dbe">Assignment 4: Data Scripting</h2>
<div class="outline-text-2" id="text-org0320dbe">
<p>
This assignment is yet more <a href="http://cs.brown.edu/courses/csci0190/2018/datascrdatascr.html">practice</a> that mirrors what a typical developer would have to do unravelling data out of nested structures and writing quick basic tasks.
</p>
</div>

<div id="outline-container-orgb372fff" class="outline-4">
<h4 id="orgb372fff">is-palindrome() and sum-largest()</h4>
<div class="outline-text-4" id="text-orgb372fff">
<p>
Straight forward to figure out using map/map2/fold.. 
</p>
</div>
</div>

<div id="outline-container-org21bd997" class="outline-4">
<h4 id="org21bd997">adding-machine()</h4>
<div class="outline-text-4" id="text-org21bd997">
<p>
Notice two consecutive 0's in the test case which will screw up your list/empty cases if you're linking on occurrences of 0 unless you filter the returned acculumator.
</p>
</div>
</div>

<div id="outline-container-orgd830ee1" class="outline-4">
<h4 id="orgd830ee1">bmi-report()</h4>
<div class="outline-text-4" id="text-orgd830ee1">
<p>
Template is:
</p>
<pre class="example">
data PHR:
  | phr(name :: String,
      height :: Number,
      weight :: Number,
      heart-rate :: Number)
end

data Report:
  | bmi-summary(under :: List&lt;String&gt;,
      healthy :: List&lt;String&gt;,
      over :: List&lt;String&gt;,
      obese :: List&lt;String&gt;)
end

fun bmi-report(phrs :: List&lt;PHR&gt;) -&gt; Report:
  ...
where:
  bmi-report([list: phr("eugene", 2, 60, 77),
      phr("matty", 1.55, 58.17, 56 ),
      phr("ray", 1.8, 55, 84),
      phr("mike", 1.5, 100, 64)]) is 
  bmi-summary([list: "eugene", "ray"], # under
    [list: "matty"],         # healthy
    [list: ],                # over
    [list: "mike"]           # obese
    )
end
</pre>

<p>
My solution was to write a helper function bmi(p :: PHR) -&gt; Number and then filter each list for under, healthy, over, obese. Return bmi-summary by mapping over those filtered lists for lam(x): x.name, try adding more test cases like the empty case, or multiple same names. Assignment claims we can assume no entry will be zero so we don't need a test case for division by zero.
</p>
</div>
</div>

<div id="outline-container-orgf236f6f" class="outline-4">
<h4 id="orgf236f6f">data-smooth()</h4>
<div class="outline-text-4" id="text-orgf236f6f">
<p>
You could want tests for empty, one element, two elements, and the given assignment example:
</p>
<pre class="example">
fun data-smooth(phrs :: List&lt;PHR&gt;) -&gt; List&lt;Number&gt;:
  doc: "Smooth heart rate data"
...
where:
  # given example from assignment writeup
  data-smooth([list: phr("eugene", 2, 60, 95),
      phr("matty", 1.55, 58.17, 102),
      phr("ray", 1.8, 55, 98),
      phr("mike", 1.5, 100, 88), phr("a", 2, 2, 105)]) is [list: 95, 295/3, 96, 97, 105]

  # empty test
  data-smooth(empty) is empty

  # one element test
  data-smooth([list: phr("spock", 3, 2, 1)]) is [list: 1]

  # two element test
  data-smooth([list: phr("spock2", 1, 2, 90), phr("spock3", 3, 4, 91)]) is [list: 90, 91]
end
</pre>
<p>
One way to try this assignment is recurse on length with (prior + l.first + l.rest.first) / 3 then before your helper function returns, append the last element which we want unchanged. Before your data-smooth function returns append the first element to .rest of what helper returned, since we want the first element unchanged too.  
</p>
</div>
</div>

<div id="outline-container-org898621b" class="outline-4">
<h4 id="org898621b">frequent-words()</h4>
<div class="outline-text-4" id="text-org898621b">
<p>
I wrote this template:
</p>

<pre class="example">
# optional
data Freq:
  | frequency(word :: String, count :: Number)
end

fun frequent-words(words :: List&lt;String&gt;) -&gt; List&lt;String&gt;:
 ...
where:
  frequent-words([list: "silver", "james", "james", "silver",
      "howlett", "silver", "loganne", "james", "loganne"])
    is  [list: "james", "silver", "loganne"]
  frequent-words([list: "a", "a", "a", "a", "b", "b", "c"]) is [list: "a", "b"]
  # corner case, all words are only 1 frequency so return sorted
  frequent-words([list: "james", "so"]) is [list: "so", "james"  ]
  frequent-words(empty) is empty
end
</pre>

<p>
The assignment wants a list returned of words, in descending order of freq count, sorted by smallest string length if there's a tie. If the highest frequency count is greater than 1, then you return those words otherwise return the list sorted if there are no freq greater than 1 is how I interpret the assignment. 
</p>
</div>
</div>

<div id="outline-container-org5d24c60" class="outline-4">
<h4 id="org5d24c60">daily-max-for-month()</h4>
<div class="outline-text-4" id="text-org5d24c60">
<p>
We're asked to take [list: 20151004, 150, 200, 175, 20151005, 0.002, 0.03, 20151007, 130, 0.54, 20151101, 78] and turn it into a daily maximum [list: max-hz(20151004, 200), max-hz(20151005, 0.03), max-hz(20151007, 130)] if the searched for month is October. Our template:
</p>

<pre class="example">
data Report:
  | max-hz(date :: Number, max-reading :: Number)
end

fun daily-max-for-month(sensor-data :: List&lt;Number&gt;, month :: Number) -&gt; List&lt;Report&gt;:
  ...
where:
  input = [list: 20151004, 150, 200, 175, 20151005, 0.002, 0.03, 20151007, 130, 0.54, 20151101, 78]
  daily-max-for-month(input, 10) is [list: max-hz(20151004, 200), max-hz(20151005, 0.03), max-hz(20151007, 130)]
end
</pre>

<p>
I completed this with 2 functions maxx(), and a helper(). I filtered sensor-data for the month desired to get a distinct list of all dates of that month [list: 20151004, 20151005, 20151007] since if you multiply month by 100, and add 20150000 you get the desired month. Then I called helper(distinct-list, sensor-data) which tested if f was a member of my distinct month list. If so I called maxx to find the highest count that day: link(max-hz(f, maxx(r), helper(distinct-list, r))). 
</p>
</div>
</div>
</div>


<div id="outline-container-org9fc5732" class="outline-2">
<h2 id="org9fc5732">Lecture 7 CS019 Trees</h2>
<div class="outline-text-2" id="text-org9fc5732">
<p>
We're watchin Fri9/21/18 lecture on 2D tree shaped data w/guest lecturer <a href="http://cs.brown.edu/~tbn/publications/">Tim Nelson</a> who is an expert in formal methods such as proving correct a network security policy as an example or formally verifying software models something we will be doing in the courses after this one. An interesting paper from his page authored with Prof K you should read is <i>The Human in Formal Methods</i>. In it they write about porting the method of example writing we've been doing to this domain. A common learning mistake that students make is talked about, in that they write programs before they have understood the problem, as a result they 'solve' the wrong problem, which misdirected from the learning goals. If you read the paper linked in the first DocDiff assignment you already know this.
</p>

<p>
The mutual recursive datatypes, to understand them write out your own tree:
</p>
<pre class="example">
       a 
      /  \   
    b    none     
   /  \
  c    none
   \ 
    none

a has child b and none
b has child c and none
c has none
</pre>

<ul class="org-ul">
<li>start with a:</li>
<li>person("a", No-children)</li>
<li>add in b:</li>
<li>person("a", <b>child(person("b", No-children)</b>, No-children))</li>
<li>add in c:</li>
<li>e2 = person("a", child(person("b", <b>child(person("c", No-children)</b>, No-children)), No-children))</li>
</ul>
</div>


<div id="outline-container-org467dc24" class="outline-3">
<h3 id="org467dc24">Reading Chapter 11</h3>
<div class="outline-text-3" id="text-org467dc24">
<p>
Cases are finally introduced here after we have used them multiple times, but now you know the meaning of the term data variant. You create a custom datatype, and cases will take it apart. 
</p>
</div>
</div>


<div id="outline-container-org47b23bf" class="outline-3">
<h3 id="org47b23bf">Reading Chapter 12</h3>
<div class="outline-text-3" id="text-org47b23bf">
<p>
Notice the typo in oldest-song() examples, using lvar instead of lver (always run the examples so they pass). In fact this chapter has a few errors, but of course they could be intentional due to that awesome disclaimer in the beginning of the book. You can rewrite oldest-song() using just a single fold statement: if (current-year - x.year) &gt; acc.year: x else: acc. Fold does all the magic for you taking anything you return such as x (the song) and puts it in the accumulator as it iterates over the list.
</p>
</div>
</div>

<div id="outline-container-org5ad3484" class="outline-3">
<h3 id="org5ad3484">Reading Chapter 13</h3>
<div class="outline-text-3" id="text-org5ad3484">
<p>
The recursive data definitions that we saw in Lecture 7, and they hand step through a recursive function. Seems like this should be in chapter 1. The design recipe template from HtDP book for recursive data definitions is also shown if you didn't read it from previously in this workshop. 
</p>
</div>
</div>
</div>

<div id="outline-container-orgb5d4773" class="outline-2">
<h2 id="orgb5d4773">Lecture 8 CS019 Sets</h2>
<div class="outline-text-2" id="text-orgb5d4773">
<p>
We're watching Mon9/24/18 lecture on sets. When he shortens insert() to equal link, try it in the pyret repl. The end of this lecture discussing the big-O complexity of both representations he points out the inefficient representation is better depending on what you care about, like appending a log you often don't look at. 
</p>
</div>

<div id="outline-container-org001a6c8" class="outline-3">
<h3 id="org001a6c8">Reading Chapter 18</h3>
<div class="outline-text-3" id="text-org001a6c8">
<p>
We haven't covered 18.2 yet so just reading 18.1, covers what we just saw in the lecture representing sets using lists. Again this is a good course because you have to manually implement everything yourself including built-ins such as all the set built-ins. 
</p>

<p>
There's a link to the <a href="https://papl.cs.brown.edu/2019/glossary.html">glossary</a>, interesting definitions in there such as links to a paper on coalgebras/coinduction. In the size() recurrence, remember the chapter <i>Predicting Growth</i> where common recurrences are listed such as T(k) = T(k - 1) + k is \([k \rightarrow k^2]\) because it's closed form solution is: \(\frac{k^2 + k}{2}\) hence T(d) = d + (d - 1) is also \([d \rightarrow d^2]\).
</p>
</div>
</div>


<div id="outline-container-orgd933ebc" class="outline-3">
<h3 id="orgd933ebc">Reading Chapter 15</h3>
<div class="outline-text-3" id="text-orgd933ebc">
<p>
This is short unfinished <a href="https://papl.cs.brown.edu/2020/testing.html">chapter</a> on testing. In testing blocks we have some new binary and unary test <a href="https://www.pyret.org/docs/latest/testing.html">operators</a> we can use like <i>expr1 is%(function) expr2</i> or <i>expr1 satisfies (function)</i>. See examples in the documentation.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb47b061" class="outline-2">
<h2 id="orgb47b061">Assignment 5: Oracle</h2>
<div class="outline-text-2" id="text-orgb47b061">
<p>
Let's build a testing <a href="http://cs.brown.edu/courses/csci0190/2019/oracleoracle.html">oracle</a>. There's a starter <a href="https://code.pyret.org/editor#share=1ZCe4jQepT5vars3-1dK8jBPVhAllLBoq&amp;v=7aff971">template</a> we need to access the function they give us matchmaker() and is-hire() 
</p>

<details>
<pre class="example">
# CSCI0190 (Fall 2018)
provide *
provide-types *

import shared-gdrive("oracle-support.arr",
  "11JjbUnU58ZJCXSphUEyIODD1YaDLAPLm") as O

##### PUT IMPORTS BELOW HERE ############


##### PUT IMPORTS ABOVE HERE ############

type Hire = O.Hire
hire = O.hire
is-hire = O.is-hire
matchmaker = O.matchmaker

# DO NOT CHANGE ANYTHING ABOVE THIS LINE

fun generate-input(num :: Number) -&gt; List&lt;List&lt;Number&gt;&gt;:
  doc: 
  ```
  generates a list of candidates or companies for a group of size num
  ```
  empty
where:
  generate-input(0) is empty
end

fun is-valid(
    companies :: List&lt;List&lt;Number&gt;&gt;,
    candidates :: List&lt;List&lt;Number&gt;&gt;,
    hires :: Set&lt;Hire&gt;)
  -&gt; Boolean:
  doc: 
  ```
  Tells if the set of hires is a good match for the given
  company and candidate preferences.
  ```
  true
where:
  is-valid(empty, empty, empty-set) is true
end

fun oracle(a-matchmaker :: (List&lt;List&lt;Number&gt;&gt;, List&lt;List&lt;Number&gt;&gt; 
      -&gt; Set&lt;Hire&gt;))
  -&gt; Boolean:
  doc: 
  ```
  Takes a purported matchmaking algorithm as input and outputs whether or
  not it always returns the correct response
  ```
  true
where:
  oracle(matchmaker) is true
end
</pre>
</details>

<p>
Run the template then try to give matchmaker some inputs to see what it does:
</p>

<pre class="example">
companies =  [list: [list: 1, 0, 2], [list: 0, 2, 1], [list: 0, 2, 1]]
candidates = [list: [list: 1, 0, 2], [list: 1, 2, 0], [list: 0, 1, 2]]
# Note matchmaker writeup: it is 0 to n-1 indexed, so 3 lists means 0 - 2 

matchmaker(companies, candidates)
&gt;&gt;[list-set: hire(2, 1), hire(1, 0), hire(0, 2)]
</pre>

<p>
First Let's understand the matching algorithm, we don't have to write one ourselves but we have to know how it works in order to test all the false matchmaker algorithms in our oracle. Let's look at the actual <a href="http://www.eecs.harvard.edu/cs286r/courses/fall09/papers/galeshapley.pdf">paper</a>. Scroll down to Theorem 1: <i>There always exists a stable set of marriages</i> and look at the proof for the algorithm:
</p>

<ul class="org-ul">
<li>First round:</li>
<li>Companies all select their first preferred candidate</li>
<li>Candidates accept provisionally, if a more preferred offer is presented in next rounds they will reject this one
<ul class="org-ul">
<li>Rejected companies are put into a pool</li>
</ul></li>
<li>Second round:</li>
<li>Companies in the pool with no matching then all select their second preferred candidate</li>
<li>Candidates accept or reject upon preferences</li>
<li>X rounds:</li>
<li>Repeat, noting that no company can offer more than once to a candidate</li>
</ul>

<p>
The 2019 assignment writeup contains a few hints, such as 'be cautious about using the provided matchmaker function in your oracle as this assumes that there is only one right answer to a given instance of the stable hiring problem'. I translate this to mean there could be many permutations of the stable-hiring problem which are still correct, however the Gale-Shipley algorithm produces the exact same matching everytime if the company is making offers, and candidates rejecting. What if the roles are reversed, if it is candidate making offers and company rejecting, is the matching then different? We have 2 inputs into matchmaker but it doesn't say which one is actually making the offers and which input is rejecting. We should try altering the inputs and see what happens: 
</p>

<pre class="example">
companies =  [list: [list: 1, 0, 2], [list: 0, 2, 1], [list: 0, 2, 1]]
candidates = [list: [list: 1, 0, 2], [list: 1, 2, 0], [list: 0, 1, 2]]

&gt;&gt;matchmaker(candidates, companies)
[list-set: hire(2,2), hire(1,0), hire(0,1)]

&gt;&gt;matchmaker(companies, candidates)
[list-set: hire(2,1), hire(1,0), hire(0,2)]
</pre>

<p>
They're different, so there is indeed more than one solution to the problem depending on if the bias is towards candidates or companies. So how are we going to test. Googling around I find an old book, entirely on the Stable Marriage problem <a href="https://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15251-f10/Site/Materials/Lectures/Lecture21/lecture21.pdf">here</a>. On page 8 <i>Stability Checking</i> we are given a stability checking algorithm and on page 7 this is more clearly defined: For each company C, look at their preferences and check that each candidate they prefer is not matched to somebody else if candidate also prefers company C.
</p>

<ul class="org-ul">
<li>Some tests to implement:
<ul class="org-ul">
<li>check the hire pairs are bounded with the input
<ul class="org-ul">
<li>no hire(7,1) if input is only 3 companies</li>
</ul></li>
<li>check n companies and n candidates are in n pairs</li>
<li>check for duplicate matchings</li>
<li>check they are actually type Hire</li>
<li>check they are stable as per the algorithm in that book</li>
</ul></li>
</ul>

<p>
This was my good enough generate-input function for test inputs &lt; num = 25, more than that and needs optimization, like using a dict or keep a sorted accumulator to check for dupes. 
</p>

<details>
<pre class="example">
fun generate-input(num :: Number) -&gt; List&lt;List&lt;Number&gt;&gt;:
  doc: 'generates a list of candidates or companies for a group of size num'
  fun test-for-dupes(input :: List&lt;Number&gt;) -&gt; List&lt;Number&gt;:
    doc: 'Checks for duplicate prefs in the list'
    distinct-input = L.distinct(input)
    if (L.length(distinct-input) &lt; num):
      test-for-dupes(distinct-input
          + map(lam(x): num-random(num) end, repeat(num - distinct-input.length(), 0)))
    else:
      input
    end
  end

  fun create-list(n :: Number) -&gt; List&lt;Number&gt;:
    doc: 'Assembles list of distinct prefs'
    randomized = map(lam(x): num-random(n) end, repeat(n, 1))
    test-for-dupes(randomized)
  end

  if (num &lt;= 0):
    # If empty, return empty
    empty
  else if num == 1: 
    # If n, return n - 1 
    [list: [list: 0]]
  else:
    # repeat gives a skeleton list to map over of size num
    map(lam(x): create-list(num) end, repeat(num, 1)) 
  end
where:
  generate-input(0) is empty
  generate-input(-1) is empty
  generate-input(1) is [list: [list: 0]]
  L.length(generate-input(3)) is 3
  # omitted a bunch of tests here
end
</pre>
</details>
</div>

<div id="outline-container-orgee8c185" class="outline-3">
<h3 id="orgee8c185">Check your solution</h3>
<div class="outline-text-3" id="text-orgee8c185">
<p>
The same <a href="https://cs.brown.edu/~sk/Publications/Papers/Published/wnk-use-rel-prob-pbt/">paper</a> we read for Sortacle assignment there is a writeup for this one too. Once again they didn't really care that much about the input generation functions. Checking my own work they cared that is-valid tested for stability, uniqueness and completeness which my tests all covered mainly because I found that old book on the stable matchmaking problem that handed me a stability testing algorithm and from years of reading hacky software I just expected disaster so tested for dupes and incompleteness. 
</p>

<p>
How they came up with these tests is a good read, they used Alloy taught in cs195y (also the book <i>Software Foundations</i> by Jackson) to produce a model where all three properties were satisfied, then had Alloy produce unstable matchings while preserving the other two properties unique and complete. 
</p>
</div>
</div>

<div id="outline-container-orgdb8347e" class="outline-3">
<h3 id="orgdb8347e">Future assignments auditing</h3>
<div class="outline-text-3" id="text-orgdb8347e">
<p>
All the 'solutions' to the assignments are in the rest of the paper, meaning what property they wanted the student to notice and test for. If you want you can do those assignments like the instructors: come up with properties to test for, write these down on paper. Come up with a relational test for each assignment. Think about what multiple correct outputs could happen for a single input. Write skeleton tests for these then read what they wanted in the paper. 
</p>

<p>
Of course it is good practice/drill to actually program from scratch each assignment if you lack experience and this of course will be much easier after you write down on paper all the properties you think should be tested. You may want to try implementing <a href="http://cs.brown.edu/courses/cs195y/2020/pages/pdf/Oracle.pdf">topological sort</a> from cs195y as there's a full solution for it in the paper noting that many students completely bombed this assignment, primarily the Python background students whereas the cs19 students and the Java background students did well on it. If you read why the author's conjecture it's because Python enables a sloppy method of programming, making it unsuitable for beginning students. Now you know why you aren't doing a Python curriculum that 99.9% of all people seem to recommend whenever you type into google 'how do I learn to program'.      
</p>
</div>
</div>
</div>

<div id="outline-container-org14d6e61" class="outline-2">
<h2 id="org14d6e61">Lecture 9 CS019 Logarithmic Growth</h2>
<div class="outline-text-2" id="text-org14d6e61">
<p>
We're watching lecture Wed/9/26/18. This is a light lecture just explaining the intuition behind logarithmic complexity to set up balanced binary search trees. At 7:10 he explains logarithms: "A (base-10) logarithm of a number is essentially how many digits a number has. That's it". He then explains in terms of virtual machine costs, if you have a logarithmic algorithm and there is a million new runs of that algorithm you are only paying 6x the cost.    
</p>
</div>
</div>

<div id="outline-container-org5e834d3" class="outline-2">
<h2 id="org5e834d3">Lecture 10 CS019 Balanced Binary Search Trees</h2>
<div class="outline-text-2" id="text-org5e834d3">
<p>
This is lecture Fri/9/28/18. We discover the entire last lecture was just trolling and would not give us logarithmic time in terms of successfully being able to throw away half the data because the tree isn't balanced. This whole lecture is understanding how you can balance a tree. There's more lectures on <a href="https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/eff/bst.html">trees</a> in future lectures. 
</p>
</div>

<div id="outline-container-org1e0b76d" class="outline-3">
<h3 id="org1e0b76d">Reading Chapter 17.2</h3>
<div class="outline-text-3" id="text-org1e0b76d">
<p>
All of <a href="https://papl.cs.brown.edu/2020/set-representations.html#(part._sets-grow-trees)">this</a> was covered in the lecture, including most of the exercises. There's an interesting writeup about how hashing functions work. 
</p>
</div>
</div>

<div id="outline-container-orga1fc806" class="outline-3">
<h3 id="orga1fc806">Lab: Tree traversal</h3>
<div class="outline-text-3" id="text-orga1fc806">
<p>
Let's try the CS019 lab for <a href="https://zacharyespiritu.com/documents/teaching/csci0190/iterating-over-trees-lab.pdf">trees</a>. The first part is just thought exercises then the lab offers us stencil code for the BT tree lab sections:
</p>

<pre class="example">
#  _____                _                                      _ 
# |_   _| __ ___  ___  | |_ _ __ __ ___   _____ _ __ ___  __ _| |
#   | || '__/ _ \/ _ \ | __| '__/ _` \ \ / / _ \ '__/ __|/ _` | |
#   | || | |  __/  __/ | |_| | | (_| |\ V /  __/ |  \__ \ (_| | |
#   |_||_|  \___|\___|  \__|_|  \__,_| \_/ \___|_|  |___/\__,_|_|

data BTree&lt;T&gt;:
  | mt
  | node(value :: T, left :: BTree&lt;T&gt;, right :: BTree&lt;T&gt;)
end

fun btree-in-order&lt;A&gt;(tree :: BTree&lt;A&gt;) -&gt; List&lt;A&gt;:
  doc: "Returns the elements of tree in a list via an in-order traversal"
  ...
where:
  nothing
end

fun btree-pre-order&lt;A&gt;(tree :: BTree&lt;A&gt;) -&gt; List&lt;A&gt;:
  doc: "Returns the elements of tree in a list via a pre-order traversal"
  ...
where:
  nothing
end

fun btree-post-order&lt;A&gt;(tree :: BTree&lt;A&gt;) -&gt; List&lt;A&gt;:
  doc: "Returns the elements of tree in a list via a post-order traversal"
  ...
where:
  nothing
end
</pre>

<p>
First make a tree, run it, and type 'a-tree' into pyret interpreter and click the output to see the right and left branches, or a-tree.left or a-tree.right
</p>

<pre class="example">
a-tree =
  node(5,
    node(4, 
      node(3, mt, mt), mt),
    node(6, node(7, mt, mt), node(8, mt, mt)))

&gt;&gt; a-tree.left
node(4, node(3, mt, mt), mt)

&gt;&gt; a-tree.right
node(6, node(7, mt, mt), node(8, mt, mt))

&gt;&gt; a-tree.value
5
</pre>

<p>
The lab wants us to write various traversals, here's what I wrote for btree-in-order which is basically the other two orders as well, just rearrange helper(l) + root + helper(r):
</p>


<pre class="example">
data BTree&lt;T&gt;:
  | mt
  | node(value :: T, left :: BTree&lt;T&gt;, right :: BTree&lt;T&gt;)
end

a-tree =
  node(5,
    node(4, 
      node(3, mt, mt), mt),
    node(6, node(7, mt, mt), node(8, mt, mt)))

# degenerate tree from PAPL chapter 17.2.2
b-tree = node(1, mt,
  node(2, mt,
    node(3, mt,
      node(4, mt, mt))))

fun btree-in-order&lt;A&gt;(tree :: BTree&lt;A&gt;) -&gt; List&lt;A&gt;:
  doc: "Returns the elements of tree in a list via an in-order traversal"

  fun helper(n :: BTree&lt;A&gt;) -&gt; List&lt;A&gt;:
    cases (BTree) n:
      | mt =&gt; empty
      | node(v, l, r) =&gt;
        link(v, helper(l) + helper(r)) 
    end
  end

  cases (BTree) tree:
    | mt =&gt; empty
    | node(v, l, r) =&gt;
      helper(l) + link(v, empty) + helper(r)
  end
where:
  btree-in-order(a-tree) is [list: 4, 3, 5, 6, 7, 8]
  btree-in-order(b-tree) is [list: 1, 2, 3, 4]
end
</pre>

<p>
Another lab where we rewrite map/filter/fold. Below when you see Prof K's lecture on knowledge transfer you'll understand why he makes us do this over and over. This is my first attempt at map, I wrote it like he writes software on the board in class thinking through the data definition:
</p>

<pre class="example">
data BTree&lt;T&gt;:
  | mt
  | node(value :: T, left :: BTree&lt;T&gt;, right :: BTree&lt;T&gt;)
end

a-tree =
  node(5,
    node(4, 
      node(3, mt, mt), mt),
    node(6, node(7, mt, mt), node(8, mt, mt)))

# degenerate tree from PAPL chapter 17.2.2
b-tree = node(1, mt,
  node(2, mt,
    node(3, mt,
      node(4, mt, mt))))

fun btree-map&lt;A, B&gt;(f :: (A -&gt; B), tree :: BTree&lt;A&gt;) -&gt; BTree&lt;B&gt;:
  doc: "Recursively applies f to the value of every node contained in tree"

  cases (BTree) tree:
    | mt =&gt; mt
    | node(v, l, r) =&gt;
      node(f(v), btree-map(f, l), btree-map(f, r))
  end
where:
  btree-map(lam(x): x + 1 end, a-tree) is node(6, node(5, node(4, mt, mt), mt), 
    node(7, node(8, mt, mt), node(9, mt, mt)))
  btree-map(lam(x): x + 1 end, b-tree) is node(2, mt, node(3, mt, node(4, mt, node(5, mt, mt))))
end

&gt;&gt;btree-map(lam(x): x * x end, a-tree)
node(25, node(16, node(9, mt, mt), mt), node(36, node(49, mt, mt), node(64, mt, mt)))

</pre>

<p>
Note that btree-fold the lab wants you to convert the tree to a list, apply f to every element and produce a value just like regular fold does with a warning about complete testing, meaning every function of regular fold should be replicated here.  
</p>
</div>
</div>
</div>

<div id="outline-container-org7a7290c" class="outline-2">
<h2 id="org7a7290c">Assignment 6: Filesystem</h2>
<div class="outline-text-2" id="text-org7a7290c">
<p>
I interpret the <a href="https://cs.brown.edu/courses/cs019/2018/filesystemfilesystem.html">assignment</a> to mean this directory tree/model:
</p>

<pre class="example">
# this is missing from my template:
type Path = List&lt;String&gt;

# you can omit size field, so c = file("name", "text") and c.size will return size 4 of the content field 'text'.  
filesystem = (dir("TS", [list:
        dir("Text", empty, [list: file("part1", 99, "content"), file("part2", 52, "content"), file("part3", 17, "content")]),   
        dir("Libs", [list: 
            dir("Code", empty, [list: file("hang", 8, "content"), file("draw", 2, "content")]), 
            dir("Docs", empty, [list: file("read!", 19, "content")])], empty)],
      [list: file("read!", 10, "content")]))
</pre>

<p>
Recall that Pyret allows you to write methods for datatype, here's an example for du-dir() where I wrote a .size() method you can call on any directory:
</p>

<pre class="example">
provide *
provide-types *

data File:
  | file(name :: String, size :: Number, content :: String)
end

data Dir:
  | dir(name :: String, ds :: List&lt;Dir&gt;, fs :: List&lt;File&gt;) with:
    method size(self :: Dir) -&gt; Number:
      doc: "Returns combined file size, file count, and sub directory count of a Dir"
      size(self)
    end
end

fun size(d :: Dir) -&gt; Number:
  doc: "Method .size()"

  fun fsize(fd :: Dir) -&gt; Number:
    doc: "Returns file size, and number of files in a Dir"
    fd.fs.foldl(lam(f :: File, acc :: Number): 1 + f.size + acc end, 0)
  end

  fsize(d)
    + map(lam(x :: Dir): 1 + size(x) end, d.ds).foldl(lam(elt, acc): elt + acc end, 0)
end
check:
  a = dir("TS", [list:
      dir("Text", empty, [list: file("part1", 1, "content")])], empty)

  b = dir("Libs", [list: 
      dir("Code", empty, [list: file("hang", 1, "content"), file("draw", 1, "content")]), 
      dir("Docs", empty, [list: file("read!", 1, "content")])], empty)

  c = dir("TS", [list:
      dir("Text", empty, [list: file("part1", 1, "content"), file("part2", 1, "content"), file("part3", 1, "content")]),   
      dir("Libs", [list: 
          dir("Code", empty, [list: file("hang", 1, "content"), file("draw", 2, "content")]), 
          dir("Docs", empty, [list: file("read!", 1, "content")])], empty)],
    [list: file("read!", 1, "content")])

  d = dir("TS", [list:
      dir("Text", empty, [list: file("part1", 99, "content"), file("part2", 52, "content"), file("part3", 17, "content")]),   
      dir("Libs", [list: 
          dir("Code", empty, [list: file("hang", 8, "content"), file("draw", 2, "content")]), 
          dir("Docs", empty, [list: file("read!", 19, "content")])], empty)],
    [list: file("read!", 10, "content")])

  e = dir("TS", empty, [list: file("", 1, "")])

  a.size() is 3
  b.size() is 8
  c.size() is 19
  d.size() is 218
  e.size() is 2
end
</pre>

<p>
This is all in the Pyret documentation, and I looked at the Pyret source on github to see how to chain multiple methods:
</p>

<pre class="example">
data Dir:
  | dir(name :: String, ds :: List&lt;Dir&gt;, fs :: List&lt;File&gt;) with:
    method size(self :: Dir) -&gt; Number:
      doc: "Returns the size of all sub directories"
      size(self)
    end,
    method path(self :: Dir, s :: String) -&gt; List&lt;Path&gt;:
      doc: "Takes a Dir, and a search string, returns the path"
      path(self, s)
    end
end
</pre>

<p>
The path method there's numerous ways you could architect this to be better. I do these exercises on a phone whenever I have spare time (commuting, lunch break, randomly get an idea somewhere) and often repeated the same annoying mistake using [list: ] instead of 'empty' which seems to break everything in Pyret.
</p>
</div>
</div>

<div id="outline-container-orgf3ab9e0" class="outline-2">
<h2 id="orgf3ab9e0">Lecture 11 CS019 Streams</h2>
<div class="outline-text-2" id="text-orgf3ab9e0">
<p>
Watching lecture titled Mon/10/01/18. In the examples of ones, everytime you invoke 'ones' you get lzlink(1, &lt;thunk&gt;) which is one, plus a way to get more ones if called again. We're asked to write our own map, you could also try it with cases:
</p>

<pre class="example">
fun maps&lt;A, B&gt;(f :: (A -&gt; B), s :: Lz&lt;A&gt;) -&gt; Lz&lt;B&gt;:
  cases (Lz&lt;A&gt;) s:
    | lzlink(e, r) =&gt; lzlink(f(e), {(): maps(f, rst(s))}) 
  end
end

fun maps2&lt;A, B, C&gt;(f :: (A, B -&gt; C), s1 :: Lz&lt;A&gt;, s2 :: Lz&lt;B&gt;) -&gt; Lz&lt;C&gt;:
  cases (Lz&lt;A&gt;) s1:
    | lzlink(e, r) =&gt; 
      cases (Lz&lt;B&gt;) s2:
        | lzlink(ee, rr) =&gt; lzlink(f(e, ee), {(): maps2(f, rst(s1), rst(s2))})
      end
  end
end

&gt;&gt;s2 = maps(lam(x): x - 1 end, nats)
&gt;&gt;take(s2, 5)
[list: -1, 0, 1, 2, 3]

&gt;&gt;s3 = maps2(lam(x, y): x + y end, nats, nats)
&gt;&gt;take(s3, 5)
[list: 0, 2, 4, 6, 8]
</pre>

<p>
The type variables annotation he used maps&lt;A,B,C&gt;(f :: (A -&gt; B),..)-&gt; Stream&lt;C&gt;: is in the streams chapter of the text and in <a href="https://papl.cs.brown.edu/2020/para-poly.html">Chapter 27</a>. 
</p>
</div>

<div id="outline-container-org8a1279c" class="outline-3">
<h3 id="org8a1279c">Reading Chapter 16</h3>
<div class="outline-text-3" id="text-org8a1279c">
<p>
The chapter on streams will explain some calculus notation converting it to a pyret function. The symbol \(\varepsilon\) is epsilon which is a small positive qty, and "functions of arity one" means one parameter or input. There's a <a href="https://www.pyret.org/docs/latest/A_Tour_of_Pyret.html#(part._.For_loops)">for loop</a> used in the check block which is an iterator. We learn more about the ( -&gt;) notation, meaning no arguments. The fibonacci example, change the starting values around so you can see what's going on. You first lz-link 0 and 1 then those values are mapped over, producing a new value, which gets mapped over again etc. 
</p>
</div>
</div>


<div id="outline-container-orgdabc4cb" class="outline-3">
<h3 id="orgdabc4cb">Lab: Streams</h3>
<div class="outline-text-3" id="text-orgdabc4cb">
<p>
The streams lab is <a href="https://cs.brown.edu/courses/cs019/2016/streams-lab.pdf">here</a>, mostly adapted from the chapter we just read in PAPL. Everything here we've already seen. We already wrote map and map2, try to write your own filter/fold for streams:
</p>

<pre class="example">
fun lz-fold&lt;A, B&gt;(f :: (A, B -&gt; A), base :: A, s :: Stream&lt;B&gt;) -&gt; Stream&lt;A&gt;:
  lz-link(f(base, lz-first(s)), lam(): lz-fold(f, f(base, lz-first(s)), lz-rest(s)) end) 
end

fun lz-filter&lt;A, B&gt;(f :: (A -&gt; Boolean), s :: Stream&lt;B&gt;) -&gt; Stream&lt;A&gt;:
  if f(lz-first(s)) == true:
    lz-link(lz-first(s), lam(): lz-filter(f, lz-rest(s)) end)
  else:
    lz-filter(f, lz-rest(s))
  end
end

&gt;&gt; take(10, lz-filter(lam(x): if x &gt; 10: true else: false end end, nats))
[list: 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]

&gt;&gt; take(10, lz-fold(lam(x, y): x + y end, 0, nats))
[list: 0, 1, 3, 6, 10, 15, 21, 28, 36, 45]
</pre>
</div>
</div>
</div>


<div id="outline-container-orgee228f9" class="outline-2">
<h2 id="orgee228f9">Lecture 12 CS019 Model View Controllers</h2>
<div class="outline-text-2" id="text-orgee228f9">
<p>
This is lecture Wed10/3/18. You can't see the entire whiteboard but it doesn't matter, this is a lecture about seperation of concerns when building large systems, how to embody the essence of a system into a model that is common to all parts of the system. He's using a demo of animation, 'ask' is cond, and in chapter 14 which is optional reading. 
</p>
</div>
</div>


<div id="outline-container-orgd636eb1" class="outline-2">
<h2 id="orgd636eb1">Lecture 13 CS019 Differential Systems</h2>
<div class="outline-text-2" id="text-orgd636eb1">
<p>
Lecture Fri10/05/18. Using same reactor model to make a point about differential systems. Interesting examples about PID controllers/reactive systems, event loops, checkpoints of the state of the system.   
</p>
</div>
</div>

<div id="outline-container-org889b37b" class="outline-2">
<h2 id="org889b37b">Lecture 14 CS019 Aliasing</h2>
<div class="outline-text-2" id="text-org889b37b">
<p>
Lecture Wed10/10/18. A great lecture about memory aliasing, introduces directed acyclic graphs, which is what <a href="https://eagain.net/articles/git-for-computer-scientists/">git</a> is.   
</p>
</div>
</div>


<div id="outline-container-org9382269" class="outline-2">
<h2 id="org9382269">Lecture 15 CS019 Monads, Sequential Computation</h2>
<div class="outline-text-2" id="text-org9382269">
<p>
Lecture Fri10/12/18. He's going over some BTree code handed out in Piazza (we don't have access), but we've seen all this code before it's just a BTree. Note the check blocks can have strings, so when you run a test you know which one failed such as check "if leaves are zero": &#x2026;test.. end. We discover this is a design pattern that allows abstracting out this pattern of carrying information and it's called monadic programming.
</p>

<p>
The end of the lecture he walks through the code of a pyret library he wrote, explaining all the complicated types and notation, you can use this to look up the source yourself when doing assignments and <a href="https://github.com/brownplt/pyret-lang/tree/horizon/src/arr/trove">read</a> the code. 
</p>
</div>
</div>


<div id="outline-container-org4075243" class="outline-2">
<h2 id="org4075243">Lectures Memory mutation</h2>
<div class="outline-text-2" id="text-org4075243">
<p>
We skipped graphs and union-find/min spanning trees because we will come back when do them later. For now let's learn about mutation. Watch lecture 23 Wed10/31/18, and skip to 40:00. Here we learn about objects such as using the 'this' keyword in java/javascript and memory referencing in C/C++. Everything in this lecture is in PAPL too such as identical which means two things are identical if changing one thing also changes the other. 
</p>

<p>
Your lecture should start with the Box datatype. "Your programs now have a notion of time" aka state, the state of things at time x. The {} expression is an <a href="https://www.pyret.org/docs/latest/Expressions.html#(elem._(bnf-prod._(.Pyret._obj-expr)))">object</a>. 
</p>
</div>

<div id="outline-container-orgc5e55eb" class="outline-3">
<h3 id="orgc5e55eb">Lecture 24 Memory refs</h3>
<div class="outline-text-3" id="text-orgc5e55eb">
<p>
More of the same topic, watching lecture Fri 11/2/18. The reference remains the same, the value can change. Once he goes back to talking about union-find abandon the lecture, we will return and watch it when we learn it in competitive programming.
</p>
</div>
</div>

<div id="outline-container-org4cb18c0" class="outline-3">
<h3 id="org4cb18c0">Lecture 25 Closures</h3>
<div class="outline-text-3" id="text-org4cb18c0">
<p>
Watching <a href="https://youtu.be/munnj3BXJCc">lecture</a> Mon 11/5/18. A part of this lecture is offscreen, but the point is equal-never is impossible to implement with state/mutation because of time, in the future it could be equal if mutated. A closure gives you dynamic environment, from the book <i>Programming in SML</i>:    
</p>

<blockquote>
<p>
One way to understand whats going on here is through the concept of a closure, a technique for implementing higher-order functions. When a function expression is evaluated, a copy of the environment is attached to the function. Subsequently, all free variables of the function (i.e., those variables not occurring as parameters) are resolved with respect to the environment attached to the function; the function is therefore said to be closed with respect to the attached environment. This is achieved at function application time by swapping the attached environment of the function for the environment active at the point of the call. The swapped environment is restored after the call is complete.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org9a6561d" class="outline-3">
<h3 id="org9a6561d">Reading Chapter 22</h3>
<div class="outline-text-3" id="text-org9a6561d">
<p>
Identical, closures and recursion is explained in this <a href="https://papl.cs.brown.edu/2020/State__Change__and_More_Equality.html">chapter</a>. Chapter 32 also has the cs173 <a href="https://papl.cs.brown.edu/2020/implementing-mutation.html">version</a> of closures.
</p>
</div>
</div>

<div id="outline-container-org5611ed5" class="outline-3">
<h3 id="org5611ed5"><span class="todo TODO">TODO</span> Lecture 26 The Halting problem</h3>
</div>
</div>

<div id="outline-container-org9c2e2e1" class="outline-2">
<h2 id="org9c2e2e1">The rest of the cs19 lectures</h2>
<div class="outline-text-2" id="text-org9c2e2e1">
<p>
We will take them as these topics come up:
</p>
<ul class="org-ul">
<li>Lecture 16 - 21 Graphs and Dijkstra's algorithm</li>
<li>Lecture 22 Brown students talk about future courses to take</li>
<li>Lecture 23 - 24 is union find/min spanning trees (and mutation we already saw)</li>
<li>Lecture 27 &amp; 28 Memoization</li>
<li>Lecture 29 Dynamic Programming</li>
<li>Lecture 30 Levenshtein Distance (spell checkers)</li>
<li>Lecture 31 P = NP</li>
<li>Lecture 32 - 34 Programming languages 
<ul class="org-ul">
<li>discusses what PL researchers do, shows you how he wrote PAPL using Racket scribble</li>
</ul></li>
<li>Lecture 35 Computer Networks</li>
<li>Lecture 36 Security</li>
</ul>
</div>
</div>
</div>
</body>
</html>
